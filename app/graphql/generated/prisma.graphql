# source: http://prisma.frank-dev1.frank.ly
# timestamp: Fri Sep 14 2018 14:12:48 GMT+0500 (Yekaterinburg Standard Time)

type Account implements Node {
  id: ID!
  name: String!
  nameNormalized: String
  balance: Float!
  revenue: Float!
  spendings: Float!
  categories(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Category!]
  payments(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Payment!]
  team(where: TeamWhereInput): Team!
  members(where: TeamMemberAccountWhereInput, orderBy: TeamMemberAccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TeamMemberAccount!]
  peers(where: PeerWhereInput, orderBy: PeerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Peer!]
  stories(where: StoryWhereInput, orderBy: StoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Story!]
  rawData: Json
}

"""A connection to a list of items."""
type AccountConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [AccountEdge]!
  aggregate: AggregateAccount!
}

input AccountCreateInput {
  name: String!
  nameNormalized: String
  balance: Float
  revenue: Float
  spendings: Float
  rawData: Json
  categories: CategoryCreateManyWithoutAccountInput
  payments: PaymentCreateManyWithoutAccountInput
  team: TeamCreateOneWithoutAccountsInput!
  members: TeamMemberAccountCreateManyWithoutAccountInput
  peers: PeerCreateManyWithoutAccountInput
  stories: StoryCreateManyWithoutAccountInput
}

input AccountCreateManyWithoutTeamInput {
  create: [AccountCreateWithoutTeamInput!]
  connect: [AccountWhereUniqueInput!]
}

input AccountCreateOneWithoutCategoriesInput {
  create: AccountCreateWithoutCategoriesInput
  connect: AccountWhereUniqueInput
}

input AccountCreateOneWithoutMembersInput {
  create: AccountCreateWithoutMembersInput
  connect: AccountWhereUniqueInput
}

input AccountCreateOneWithoutPaymentsInput {
  create: AccountCreateWithoutPaymentsInput
  connect: AccountWhereUniqueInput
}

input AccountCreateOneWithoutPeersInput {
  create: AccountCreateWithoutPeersInput
  connect: AccountWhereUniqueInput
}

input AccountCreateOneWithoutStoriesInput {
  create: AccountCreateWithoutStoriesInput
  connect: AccountWhereUniqueInput
}

input AccountCreateWithoutCategoriesInput {
  name: String!
  nameNormalized: String
  balance: Float
  revenue: Float
  spendings: Float
  rawData: Json
  payments: PaymentCreateManyWithoutAccountInput
  team: TeamCreateOneWithoutAccountsInput!
  members: TeamMemberAccountCreateManyWithoutAccountInput
  peers: PeerCreateManyWithoutAccountInput
  stories: StoryCreateManyWithoutAccountInput
}

input AccountCreateWithoutMembersInput {
  name: String!
  nameNormalized: String
  balance: Float
  revenue: Float
  spendings: Float
  rawData: Json
  categories: CategoryCreateManyWithoutAccountInput
  payments: PaymentCreateManyWithoutAccountInput
  team: TeamCreateOneWithoutAccountsInput!
  peers: PeerCreateManyWithoutAccountInput
  stories: StoryCreateManyWithoutAccountInput
}

input AccountCreateWithoutPaymentsInput {
  name: String!
  nameNormalized: String
  balance: Float
  revenue: Float
  spendings: Float
  rawData: Json
  categories: CategoryCreateManyWithoutAccountInput
  team: TeamCreateOneWithoutAccountsInput!
  members: TeamMemberAccountCreateManyWithoutAccountInput
  peers: PeerCreateManyWithoutAccountInput
  stories: StoryCreateManyWithoutAccountInput
}

input AccountCreateWithoutPeersInput {
  name: String!
  nameNormalized: String
  balance: Float
  revenue: Float
  spendings: Float
  rawData: Json
  categories: CategoryCreateManyWithoutAccountInput
  payments: PaymentCreateManyWithoutAccountInput
  team: TeamCreateOneWithoutAccountsInput!
  members: TeamMemberAccountCreateManyWithoutAccountInput
  stories: StoryCreateManyWithoutAccountInput
}

input AccountCreateWithoutStoriesInput {
  name: String!
  nameNormalized: String
  balance: Float
  revenue: Float
  spendings: Float
  rawData: Json
  categories: CategoryCreateManyWithoutAccountInput
  payments: PaymentCreateManyWithoutAccountInput
  team: TeamCreateOneWithoutAccountsInput!
  members: TeamMemberAccountCreateManyWithoutAccountInput
  peers: PeerCreateManyWithoutAccountInput
}

input AccountCreateWithoutTeamInput {
  name: String!
  nameNormalized: String
  balance: Float
  revenue: Float
  spendings: Float
  rawData: Json
  categories: CategoryCreateManyWithoutAccountInput
  payments: PaymentCreateManyWithoutAccountInput
  members: TeamMemberAccountCreateManyWithoutAccountInput
  peers: PeerCreateManyWithoutAccountInput
  stories: StoryCreateManyWithoutAccountInput
}

"""An edge in a connection."""
type AccountEdge {
  """The item at the end of the edge."""
  node: Account!

  """A cursor for use in pagination."""
  cursor: String!
}

enum AccountOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  nameNormalized_ASC
  nameNormalized_DESC
  balance_ASC
  balance_DESC
  revenue_ASC
  revenue_DESC
  spendings_ASC
  spendings_DESC
  rawData_ASC
  rawData_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type AccountPreviousValues {
  id: ID!
  name: String!
  nameNormalized: String
  balance: Float!
  revenue: Float!
  spendings: Float!
  rawData: Json
}

type AccountSubscriptionPayload {
  mutation: MutationType!
  node: Account
  updatedFields: [String!]
  previousValues: AccountPreviousValues
}

input AccountSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [AccountSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [AccountSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [AccountSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: AccountWhereInput
}

input AccountUpdateInput {
  name: String
  nameNormalized: String
  balance: Float
  revenue: Float
  spendings: Float
  rawData: Json
  categories: CategoryUpdateManyWithoutAccountInput
  payments: PaymentUpdateManyWithoutAccountInput
  team: TeamUpdateOneWithoutAccountsInput
  members: TeamMemberAccountUpdateManyWithoutAccountInput
  peers: PeerUpdateManyWithoutAccountInput
  stories: StoryUpdateManyWithoutAccountInput
}

input AccountUpdateManyWithoutTeamInput {
  create: [AccountCreateWithoutTeamInput!]
  connect: [AccountWhereUniqueInput!]
  disconnect: [AccountWhereUniqueInput!]
  delete: [AccountWhereUniqueInput!]
  update: [AccountUpdateWithWhereUniqueWithoutTeamInput!]
  upsert: [AccountUpsertWithWhereUniqueWithoutTeamInput!]
}

input AccountUpdateOneWithoutCategoriesInput {
  create: AccountCreateWithoutCategoriesInput
  connect: AccountWhereUniqueInput
  delete: Boolean
  update: AccountUpdateWithoutCategoriesDataInput
  upsert: AccountUpsertWithoutCategoriesInput
}

input AccountUpdateOneWithoutMembersInput {
  create: AccountCreateWithoutMembersInput
  connect: AccountWhereUniqueInput
  delete: Boolean
  update: AccountUpdateWithoutMembersDataInput
  upsert: AccountUpsertWithoutMembersInput
}

input AccountUpdateOneWithoutPaymentsInput {
  create: AccountCreateWithoutPaymentsInput
  connect: AccountWhereUniqueInput
  delete: Boolean
  update: AccountUpdateWithoutPaymentsDataInput
  upsert: AccountUpsertWithoutPaymentsInput
}

input AccountUpdateOneWithoutPeersInput {
  create: AccountCreateWithoutPeersInput
  connect: AccountWhereUniqueInput
  delete: Boolean
  update: AccountUpdateWithoutPeersDataInput
  upsert: AccountUpsertWithoutPeersInput
}

input AccountUpdateOneWithoutStoriesInput {
  create: AccountCreateWithoutStoriesInput
  connect: AccountWhereUniqueInput
  delete: Boolean
  update: AccountUpdateWithoutStoriesDataInput
  upsert: AccountUpsertWithoutStoriesInput
}

input AccountUpdateWithoutCategoriesDataInput {
  name: String
  nameNormalized: String
  balance: Float
  revenue: Float
  spendings: Float
  rawData: Json
  payments: PaymentUpdateManyWithoutAccountInput
  team: TeamUpdateOneWithoutAccountsInput
  members: TeamMemberAccountUpdateManyWithoutAccountInput
  peers: PeerUpdateManyWithoutAccountInput
  stories: StoryUpdateManyWithoutAccountInput
}

input AccountUpdateWithoutMembersDataInput {
  name: String
  nameNormalized: String
  balance: Float
  revenue: Float
  spendings: Float
  rawData: Json
  categories: CategoryUpdateManyWithoutAccountInput
  payments: PaymentUpdateManyWithoutAccountInput
  team: TeamUpdateOneWithoutAccountsInput
  peers: PeerUpdateManyWithoutAccountInput
  stories: StoryUpdateManyWithoutAccountInput
}

input AccountUpdateWithoutPaymentsDataInput {
  name: String
  nameNormalized: String
  balance: Float
  revenue: Float
  spendings: Float
  rawData: Json
  categories: CategoryUpdateManyWithoutAccountInput
  team: TeamUpdateOneWithoutAccountsInput
  members: TeamMemberAccountUpdateManyWithoutAccountInput
  peers: PeerUpdateManyWithoutAccountInput
  stories: StoryUpdateManyWithoutAccountInput
}

input AccountUpdateWithoutPeersDataInput {
  name: String
  nameNormalized: String
  balance: Float
  revenue: Float
  spendings: Float
  rawData: Json
  categories: CategoryUpdateManyWithoutAccountInput
  payments: PaymentUpdateManyWithoutAccountInput
  team: TeamUpdateOneWithoutAccountsInput
  members: TeamMemberAccountUpdateManyWithoutAccountInput
  stories: StoryUpdateManyWithoutAccountInput
}

input AccountUpdateWithoutStoriesDataInput {
  name: String
  nameNormalized: String
  balance: Float
  revenue: Float
  spendings: Float
  rawData: Json
  categories: CategoryUpdateManyWithoutAccountInput
  payments: PaymentUpdateManyWithoutAccountInput
  team: TeamUpdateOneWithoutAccountsInput
  members: TeamMemberAccountUpdateManyWithoutAccountInput
  peers: PeerUpdateManyWithoutAccountInput
}

input AccountUpdateWithoutTeamDataInput {
  name: String
  nameNormalized: String
  balance: Float
  revenue: Float
  spendings: Float
  rawData: Json
  categories: CategoryUpdateManyWithoutAccountInput
  payments: PaymentUpdateManyWithoutAccountInput
  members: TeamMemberAccountUpdateManyWithoutAccountInput
  peers: PeerUpdateManyWithoutAccountInput
  stories: StoryUpdateManyWithoutAccountInput
}

input AccountUpdateWithWhereUniqueWithoutTeamInput {
  where: AccountWhereUniqueInput!
  data: AccountUpdateWithoutTeamDataInput!
}

input AccountUpsertWithoutCategoriesInput {
  update: AccountUpdateWithoutCategoriesDataInput!
  create: AccountCreateWithoutCategoriesInput!
}

input AccountUpsertWithoutMembersInput {
  update: AccountUpdateWithoutMembersDataInput!
  create: AccountCreateWithoutMembersInput!
}

input AccountUpsertWithoutPaymentsInput {
  update: AccountUpdateWithoutPaymentsDataInput!
  create: AccountCreateWithoutPaymentsInput!
}

input AccountUpsertWithoutPeersInput {
  update: AccountUpdateWithoutPeersDataInput!
  create: AccountCreateWithoutPeersInput!
}

input AccountUpsertWithoutStoriesInput {
  update: AccountUpdateWithoutStoriesDataInput!
  create: AccountCreateWithoutStoriesInput!
}

input AccountUpsertWithWhereUniqueWithoutTeamInput {
  where: AccountWhereUniqueInput!
  update: AccountUpdateWithoutTeamDataInput!
  create: AccountCreateWithoutTeamInput!
}

input AccountWhereInput {
  """Logical AND on all given filters."""
  AND: [AccountWhereInput!]

  """Logical OR on all given filters."""
  OR: [AccountWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [AccountWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  nameNormalized: String

  """All values that are not equal to given value."""
  nameNormalized_not: String

  """All values that are contained in given list."""
  nameNormalized_in: [String!]

  """All values that are not contained in given list."""
  nameNormalized_not_in: [String!]

  """All values less than the given value."""
  nameNormalized_lt: String

  """All values less than or equal the given value."""
  nameNormalized_lte: String

  """All values greater than the given value."""
  nameNormalized_gt: String

  """All values greater than or equal the given value."""
  nameNormalized_gte: String

  """All values containing the given string."""
  nameNormalized_contains: String

  """All values not containing the given string."""
  nameNormalized_not_contains: String

  """All values starting with the given string."""
  nameNormalized_starts_with: String

  """All values not starting with the given string."""
  nameNormalized_not_starts_with: String

  """All values ending with the given string."""
  nameNormalized_ends_with: String

  """All values not ending with the given string."""
  nameNormalized_not_ends_with: String
  balance: Float

  """All values that are not equal to given value."""
  balance_not: Float

  """All values that are contained in given list."""
  balance_in: [Float!]

  """All values that are not contained in given list."""
  balance_not_in: [Float!]

  """All values less than the given value."""
  balance_lt: Float

  """All values less than or equal the given value."""
  balance_lte: Float

  """All values greater than the given value."""
  balance_gt: Float

  """All values greater than or equal the given value."""
  balance_gte: Float
  revenue: Float

  """All values that are not equal to given value."""
  revenue_not: Float

  """All values that are contained in given list."""
  revenue_in: [Float!]

  """All values that are not contained in given list."""
  revenue_not_in: [Float!]

  """All values less than the given value."""
  revenue_lt: Float

  """All values less than or equal the given value."""
  revenue_lte: Float

  """All values greater than the given value."""
  revenue_gt: Float

  """All values greater than or equal the given value."""
  revenue_gte: Float
  spendings: Float

  """All values that are not equal to given value."""
  spendings_not: Float

  """All values that are contained in given list."""
  spendings_in: [Float!]

  """All values that are not contained in given list."""
  spendings_not_in: [Float!]

  """All values less than the given value."""
  spendings_lt: Float

  """All values less than or equal the given value."""
  spendings_lte: Float

  """All values greater than the given value."""
  spendings_gt: Float

  """All values greater than or equal the given value."""
  spendings_gte: Float
  categories_every: CategoryWhereInput
  categories_some: CategoryWhereInput
  categories_none: CategoryWhereInput
  payments_every: PaymentWhereInput
  payments_some: PaymentWhereInput
  payments_none: PaymentWhereInput
  team: TeamWhereInput
  members_every: TeamMemberAccountWhereInput
  members_some: TeamMemberAccountWhereInput
  members_none: TeamMemberAccountWhereInput
  peers_every: PeerWhereInput
  peers_some: PeerWhereInput
  peers_none: PeerWhereInput
  stories_every: StoryWhereInput
  stories_some: StoryWhereInput
  stories_none: StoryWhereInput
}

input AccountWhereUniqueInput {
  id: ID
}

type AggregateAccount {
  count: Int!
}

type AggregateCategory {
  count: Int!
}

type AggregateComment {
  count: Int!
}

type AggregateOnboarding {
  count: Int!
}

type AggregatePayment {
  count: Int!
}

type AggregatePeer {
  count: Int!
}

type AggregatePeerCategory {
  count: Int!
}

type AggregateStory {
  count: Int!
}

type AggregateStoryData {
  count: Int!
}

type AggregateTeam {
  count: Int!
}

type AggregateTeamMember {
  count: Int!
}

type AggregateTeamMemberAccount {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  """The number of nodes that have been affected by the Batch operation."""
  count: Long!
}

type Category implements Node {
  id: ID!
  account(where: AccountWhereInput): Account!
  name: String!
  nameNormalized: String
  color: String!
  peers(where: PeerCategoryWhereInput, orderBy: PeerCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PeerCategory!]
}

"""A connection to a list of items."""
type CategoryConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [CategoryEdge]!
  aggregate: AggregateCategory!
}

input CategoryCreateInput {
  name: String!
  nameNormalized: String
  color: String!
  account: AccountCreateOneWithoutCategoriesInput!
  peers: PeerCategoryCreateManyWithoutCategoryInput
}

input CategoryCreateManyWithoutAccountInput {
  create: [CategoryCreateWithoutAccountInput!]
  connect: [CategoryWhereUniqueInput!]
}

input CategoryCreateOneInput {
  create: CategoryCreateInput
  connect: CategoryWhereUniqueInput
}

input CategoryCreateOneWithoutPeersInput {
  create: CategoryCreateWithoutPeersInput
  connect: CategoryWhereUniqueInput
}

input CategoryCreateWithoutAccountInput {
  name: String!
  nameNormalized: String
  color: String!
  peers: PeerCategoryCreateManyWithoutCategoryInput
}

input CategoryCreateWithoutPeersInput {
  name: String!
  nameNormalized: String
  color: String!
  account: AccountCreateOneWithoutCategoriesInput!
}

"""An edge in a connection."""
type CategoryEdge {
  """The item at the end of the edge."""
  node: Category!

  """A cursor for use in pagination."""
  cursor: String!
}

enum CategoryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  nameNormalized_ASC
  nameNormalized_DESC
  color_ASC
  color_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type CategoryPreviousValues {
  id: ID!
  name: String!
  nameNormalized: String
  color: String!
}

type CategorySubscriptionPayload {
  mutation: MutationType!
  node: Category
  updatedFields: [String!]
  previousValues: CategoryPreviousValues
}

input CategorySubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [CategorySubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [CategorySubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CategorySubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CategoryWhereInput
}

input CategoryUpdateDataInput {
  name: String
  nameNormalized: String
  color: String
  account: AccountUpdateOneWithoutCategoriesInput
  peers: PeerCategoryUpdateManyWithoutCategoryInput
}

input CategoryUpdateInput {
  name: String
  nameNormalized: String
  color: String
  account: AccountUpdateOneWithoutCategoriesInput
  peers: PeerCategoryUpdateManyWithoutCategoryInput
}

input CategoryUpdateManyWithoutAccountInput {
  create: [CategoryCreateWithoutAccountInput!]
  connect: [CategoryWhereUniqueInput!]
  disconnect: [CategoryWhereUniqueInput!]
  delete: [CategoryWhereUniqueInput!]
  update: [CategoryUpdateWithWhereUniqueWithoutAccountInput!]
  upsert: [CategoryUpsertWithWhereUniqueWithoutAccountInput!]
}

input CategoryUpdateOneInput {
  create: CategoryCreateInput
  connect: CategoryWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: CategoryUpdateDataInput
  upsert: CategoryUpsertNestedInput
}

input CategoryUpdateOneWithoutPeersInput {
  create: CategoryCreateWithoutPeersInput
  connect: CategoryWhereUniqueInput
  delete: Boolean
  update: CategoryUpdateWithoutPeersDataInput
  upsert: CategoryUpsertWithoutPeersInput
}

input CategoryUpdateWithoutAccountDataInput {
  name: String
  nameNormalized: String
  color: String
  peers: PeerCategoryUpdateManyWithoutCategoryInput
}

input CategoryUpdateWithoutPeersDataInput {
  name: String
  nameNormalized: String
  color: String
  account: AccountUpdateOneWithoutCategoriesInput
}

input CategoryUpdateWithWhereUniqueWithoutAccountInput {
  where: CategoryWhereUniqueInput!
  data: CategoryUpdateWithoutAccountDataInput!
}

input CategoryUpsertNestedInput {
  update: CategoryUpdateDataInput!
  create: CategoryCreateInput!
}

input CategoryUpsertWithoutPeersInput {
  update: CategoryUpdateWithoutPeersDataInput!
  create: CategoryCreateWithoutPeersInput!
}

input CategoryUpsertWithWhereUniqueWithoutAccountInput {
  where: CategoryWhereUniqueInput!
  update: CategoryUpdateWithoutAccountDataInput!
  create: CategoryCreateWithoutAccountInput!
}

input CategoryWhereInput {
  """Logical AND on all given filters."""
  AND: [CategoryWhereInput!]

  """Logical OR on all given filters."""
  OR: [CategoryWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CategoryWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  nameNormalized: String

  """All values that are not equal to given value."""
  nameNormalized_not: String

  """All values that are contained in given list."""
  nameNormalized_in: [String!]

  """All values that are not contained in given list."""
  nameNormalized_not_in: [String!]

  """All values less than the given value."""
  nameNormalized_lt: String

  """All values less than or equal the given value."""
  nameNormalized_lte: String

  """All values greater than the given value."""
  nameNormalized_gt: String

  """All values greater than or equal the given value."""
  nameNormalized_gte: String

  """All values containing the given string."""
  nameNormalized_contains: String

  """All values not containing the given string."""
  nameNormalized_not_contains: String

  """All values starting with the given string."""
  nameNormalized_starts_with: String

  """All values not starting with the given string."""
  nameNormalized_not_starts_with: String

  """All values ending with the given string."""
  nameNormalized_ends_with: String

  """All values not ending with the given string."""
  nameNormalized_not_ends_with: String
  color: String

  """All values that are not equal to given value."""
  color_not: String

  """All values that are contained in given list."""
  color_in: [String!]

  """All values that are not contained in given list."""
  color_not_in: [String!]

  """All values less than the given value."""
  color_lt: String

  """All values less than or equal the given value."""
  color_lte: String

  """All values greater than the given value."""
  color_gt: String

  """All values greater than or equal the given value."""
  color_gte: String

  """All values containing the given string."""
  color_contains: String

  """All values not containing the given string."""
  color_not_contains: String

  """All values starting with the given string."""
  color_starts_with: String

  """All values not starting with the given string."""
  color_not_starts_with: String

  """All values ending with the given string."""
  color_ends_with: String

  """All values not ending with the given string."""
  color_not_ends_with: String
  account: AccountWhereInput
  peers_every: PeerCategoryWhereInput
  peers_some: PeerCategoryWhereInput
  peers_none: PeerCategoryWhereInput
}

input CategoryWhereUniqueInput {
  id: ID
}

type Comment implements Node {
  id: ID!
  payment(where: PaymentWhereInput): Payment!
  user(where: UserWhereInput): User
  body: Json!
}

"""A connection to a list of items."""
type CommentConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [CommentEdge]!
  aggregate: AggregateComment!
}

input CommentCreateInput {
  body: Json!
  payment: PaymentCreateOneWithoutCommentsInput!
  user: UserCreateOneInput
}

input CommentCreateManyWithoutPaymentInput {
  create: [CommentCreateWithoutPaymentInput!]
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateWithoutPaymentInput {
  body: Json!
  user: UserCreateOneInput
}

"""An edge in a connection."""
type CommentEdge {
  """The item at the end of the edge."""
  node: Comment!

  """A cursor for use in pagination."""
  cursor: String!
}

enum CommentOrderByInput {
  id_ASC
  id_DESC
  body_ASC
  body_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type CommentPreviousValues {
  id: ID!
  body: Json!
}

type CommentSubscriptionPayload {
  mutation: MutationType!
  node: Comment
  updatedFields: [String!]
  previousValues: CommentPreviousValues
}

input CommentSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [CommentSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [CommentSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CommentSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CommentWhereInput
}

input CommentUpdateInput {
  body: Json
  payment: PaymentUpdateOneWithoutCommentsInput
  user: UserUpdateOneInput
}

input CommentUpdateManyWithoutPaymentInput {
  create: [CommentCreateWithoutPaymentInput!]
  connect: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  delete: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutPaymentInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutPaymentInput!]
}

input CommentUpdateWithoutPaymentDataInput {
  body: Json
  user: UserUpdateOneInput
}

input CommentUpdateWithWhereUniqueWithoutPaymentInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutPaymentDataInput!
}

input CommentUpsertWithWhereUniqueWithoutPaymentInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutPaymentDataInput!
  create: CommentCreateWithoutPaymentInput!
}

input CommentWhereInput {
  """Logical AND on all given filters."""
  AND: [CommentWhereInput!]

  """Logical OR on all given filters."""
  OR: [CommentWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CommentWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  payment: PaymentWhereInput
  user: UserWhereInput
}

input CommentWhereUniqueInput {
  id: ID
}

scalar DateTime

"""Raw JSON value"""
scalar Json

"""
The `Long` scalar type represents non-fractional signed whole numeric values.
Long can represent values between -(2^63) and 2^63 - 1.
"""
scalar Long

type Mutation {
  createTeam(data: TeamCreateInput!): Team!
  createTeamMember(data: TeamMemberCreateInput!): TeamMember!
  createAccount(data: AccountCreateInput!): Account!
  createTeamMemberAccount(data: TeamMemberAccountCreateInput!): TeamMemberAccount!
  createPayment(data: PaymentCreateInput!): Payment!
  createPeer(data: PeerCreateInput!): Peer!
  createComment(data: CommentCreateInput!): Comment!
  createPeerCategory(data: PeerCategoryCreateInput!): PeerCategory!
  createStory(data: StoryCreateInput!): Story!
  createStoryData(data: StoryDataCreateInput!): StoryData!
  createOnboarding(data: OnboardingCreateInput!): Onboarding!
  createUser(data: UserCreateInput!): User!
  createCategory(data: CategoryCreateInput!): Category!
  updateTeam(data: TeamUpdateInput!, where: TeamWhereUniqueInput!): Team
  updateTeamMember(data: TeamMemberUpdateInput!, where: TeamMemberWhereUniqueInput!): TeamMember
  updateAccount(data: AccountUpdateInput!, where: AccountWhereUniqueInput!): Account
  updateTeamMemberAccount(data: TeamMemberAccountUpdateInput!, where: TeamMemberAccountWhereUniqueInput!): TeamMemberAccount
  updatePayment(data: PaymentUpdateInput!, where: PaymentWhereUniqueInput!): Payment
  updatePeer(data: PeerUpdateInput!, where: PeerWhereUniqueInput!): Peer
  updateComment(data: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment
  updatePeerCategory(data: PeerCategoryUpdateInput!, where: PeerCategoryWhereUniqueInput!): PeerCategory
  updateStory(data: StoryUpdateInput!, where: StoryWhereUniqueInput!): Story
  updateOnboarding(data: OnboardingUpdateInput!, where: OnboardingWhereUniqueInput!): Onboarding
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateCategory(data: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category
  deleteTeam(where: TeamWhereUniqueInput!): Team
  deleteTeamMember(where: TeamMemberWhereUniqueInput!): TeamMember
  deleteAccount(where: AccountWhereUniqueInput!): Account
  deleteTeamMemberAccount(where: TeamMemberAccountWhereUniqueInput!): TeamMemberAccount
  deletePayment(where: PaymentWhereUniqueInput!): Payment
  deletePeer(where: PeerWhereUniqueInput!): Peer
  deleteComment(where: CommentWhereUniqueInput!): Comment
  deletePeerCategory(where: PeerCategoryWhereUniqueInput!): PeerCategory
  deleteStory(where: StoryWhereUniqueInput!): Story
  deleteOnboarding(where: OnboardingWhereUniqueInput!): Onboarding
  deleteUser(where: UserWhereUniqueInput!): User
  deleteCategory(where: CategoryWhereUniqueInput!): Category
  upsertTeam(where: TeamWhereUniqueInput!, create: TeamCreateInput!, update: TeamUpdateInput!): Team!
  upsertTeamMember(where: TeamMemberWhereUniqueInput!, create: TeamMemberCreateInput!, update: TeamMemberUpdateInput!): TeamMember!
  upsertAccount(where: AccountWhereUniqueInput!, create: AccountCreateInput!, update: AccountUpdateInput!): Account!
  upsertTeamMemberAccount(where: TeamMemberAccountWhereUniqueInput!, create: TeamMemberAccountCreateInput!, update: TeamMemberAccountUpdateInput!): TeamMemberAccount!
  upsertPayment(where: PaymentWhereUniqueInput!, create: PaymentCreateInput!, update: PaymentUpdateInput!): Payment!
  upsertPeer(where: PeerWhereUniqueInput!, create: PeerCreateInput!, update: PeerUpdateInput!): Peer!
  upsertComment(where: CommentWhereUniqueInput!, create: CommentCreateInput!, update: CommentUpdateInput!): Comment!
  upsertPeerCategory(where: PeerCategoryWhereUniqueInput!, create: PeerCategoryCreateInput!, update: PeerCategoryUpdateInput!): PeerCategory!
  upsertStory(where: StoryWhereUniqueInput!, create: StoryCreateInput!, update: StoryUpdateInput!): Story!
  upsertOnboarding(where: OnboardingWhereUniqueInput!, create: OnboardingCreateInput!, update: OnboardingUpdateInput!): Onboarding!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  upsertCategory(where: CategoryWhereUniqueInput!, create: CategoryCreateInput!, update: CategoryUpdateInput!): Category!
  updateManyTeams(data: TeamUpdateInput!, where: TeamWhereInput): BatchPayload!
  updateManyTeamMembers(data: TeamMemberUpdateInput!, where: TeamMemberWhereInput): BatchPayload!
  updateManyAccounts(data: AccountUpdateInput!, where: AccountWhereInput): BatchPayload!
  updateManyTeamMemberAccounts(data: TeamMemberAccountUpdateInput!, where: TeamMemberAccountWhereInput): BatchPayload!
  updateManyPayments(data: PaymentUpdateInput!, where: PaymentWhereInput): BatchPayload!
  updateManyPeers(data: PeerUpdateInput!, where: PeerWhereInput): BatchPayload!
  updateManyComments(data: CommentUpdateInput!, where: CommentWhereInput): BatchPayload!
  updateManyPeerCategories(data: PeerCategoryUpdateInput!, where: PeerCategoryWhereInput): BatchPayload!
  updateManyStories(data: StoryUpdateInput!, where: StoryWhereInput): BatchPayload!
  updateManyStoryDatas(data: StoryDataUpdateInput!, where: StoryDataWhereInput): BatchPayload!
  updateManyOnboardings(data: OnboardingUpdateInput!, where: OnboardingWhereInput): BatchPayload!
  updateManyUsers(data: UserUpdateInput!, where: UserWhereInput): BatchPayload!
  updateManyCategories(data: CategoryUpdateInput!, where: CategoryWhereInput): BatchPayload!
  deleteManyTeams(where: TeamWhereInput): BatchPayload!
  deleteManyTeamMembers(where: TeamMemberWhereInput): BatchPayload!
  deleteManyAccounts(where: AccountWhereInput): BatchPayload!
  deleteManyTeamMemberAccounts(where: TeamMemberAccountWhereInput): BatchPayload!
  deleteManyPayments(where: PaymentWhereInput): BatchPayload!
  deleteManyPeers(where: PeerWhereInput): BatchPayload!
  deleteManyComments(where: CommentWhereInput): BatchPayload!
  deleteManyPeerCategories(where: PeerCategoryWhereInput): BatchPayload!
  deleteManyStories(where: StoryWhereInput): BatchPayload!
  deleteManyStoryDatas(where: StoryDataWhereInput): BatchPayload!
  deleteManyOnboardings(where: OnboardingWhereInput): BatchPayload!
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  deleteManyCategories(where: CategoryWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

"""An object with an ID"""
interface Node {
  """The id of the object."""
  id: ID!
}

type Onboarding implements Node {
  id: ID!
  user(where: UserWhereInput): User!
  step: String!
  institution: Json!
  credentials: Json!
  accounts: Json
  account: Json
  categories: Json
  memberGuid: String
}

"""A connection to a list of items."""
type OnboardingConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [OnboardingEdge]!
  aggregate: AggregateOnboarding!
}

input OnboardingCreateInput {
  step: String!
  institution: Json!
  credentials: Json!
  accounts: Json
  account: Json
  categories: Json
  memberGuid: String
  user: UserCreateOneInput!
}

"""An edge in a connection."""
type OnboardingEdge {
  """The item at the end of the edge."""
  node: Onboarding!

  """A cursor for use in pagination."""
  cursor: String!
}

enum OnboardingOrderByInput {
  id_ASC
  id_DESC
  step_ASC
  step_DESC
  institution_ASC
  institution_DESC
  credentials_ASC
  credentials_DESC
  accounts_ASC
  accounts_DESC
  account_ASC
  account_DESC
  categories_ASC
  categories_DESC
  memberGuid_ASC
  memberGuid_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type OnboardingPreviousValues {
  id: ID!
  step: String!
  institution: Json!
  credentials: Json!
  accounts: Json
  account: Json
  categories: Json
  memberGuid: String
}

type OnboardingSubscriptionPayload {
  mutation: MutationType!
  node: Onboarding
  updatedFields: [String!]
  previousValues: OnboardingPreviousValues
}

input OnboardingSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [OnboardingSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [OnboardingSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [OnboardingSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: OnboardingWhereInput
}

input OnboardingUpdateInput {
  step: String
  institution: Json
  credentials: Json
  accounts: Json
  account: Json
  categories: Json
  memberGuid: String
  user: UserUpdateOneInput
}

input OnboardingWhereInput {
  """Logical AND on all given filters."""
  AND: [OnboardingWhereInput!]

  """Logical OR on all given filters."""
  OR: [OnboardingWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [OnboardingWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  step: String

  """All values that are not equal to given value."""
  step_not: String

  """All values that are contained in given list."""
  step_in: [String!]

  """All values that are not contained in given list."""
  step_not_in: [String!]

  """All values less than the given value."""
  step_lt: String

  """All values less than or equal the given value."""
  step_lte: String

  """All values greater than the given value."""
  step_gt: String

  """All values greater than or equal the given value."""
  step_gte: String

  """All values containing the given string."""
  step_contains: String

  """All values not containing the given string."""
  step_not_contains: String

  """All values starting with the given string."""
  step_starts_with: String

  """All values not starting with the given string."""
  step_not_starts_with: String

  """All values ending with the given string."""
  step_ends_with: String

  """All values not ending with the given string."""
  step_not_ends_with: String
  memberGuid: String

  """All values that are not equal to given value."""
  memberGuid_not: String

  """All values that are contained in given list."""
  memberGuid_in: [String!]

  """All values that are not contained in given list."""
  memberGuid_not_in: [String!]

  """All values less than the given value."""
  memberGuid_lt: String

  """All values less than or equal the given value."""
  memberGuid_lte: String

  """All values greater than the given value."""
  memberGuid_gt: String

  """All values greater than or equal the given value."""
  memberGuid_gte: String

  """All values containing the given string."""
  memberGuid_contains: String

  """All values not containing the given string."""
  memberGuid_not_contains: String

  """All values starting with the given string."""
  memberGuid_starts_with: String

  """All values not starting with the given string."""
  memberGuid_not_starts_with: String

  """All values ending with the given string."""
  memberGuid_ends_with: String

  """All values not ending with the given string."""
  memberGuid_not_ends_with: String
  user: UserWhereInput
}

input OnboardingWhereUniqueInput {
  id: ID
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

type Payment implements Node {
  id: ID!
  account(where: AccountWhereInput): Account!
  postedOn: DateTime!
  amount: Float!
  peerName: String
  peerNameNormalized: String
  peer(where: PeerWhereInput): Peer
  description: String
  descriptionNormalized: String
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
  category(where: CategoryWhereInput): Category
  rawData: Json!
  storyData(where: StoryDataWhereInput): StoryData
}

"""A connection to a list of items."""
type PaymentConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [PaymentEdge]!
  aggregate: AggregatePayment!
}

input PaymentCreateInput {
  postedOn: DateTime!
  amount: Float!
  peerName: String
  peerNameNormalized: String
  description: String
  descriptionNormalized: String
  rawData: Json!
  account: AccountCreateOneWithoutPaymentsInput!
  peer: PeerCreateOneWithoutPaymentsInput
  comments: CommentCreateManyWithoutPaymentInput
  category: CategoryCreateOneInput
  storyData: StoryDataCreateOneWithoutPaymentsInput
}

input PaymentCreateManyWithoutAccountInput {
  create: [PaymentCreateWithoutAccountInput!]
  connect: [PaymentWhereUniqueInput!]
}

input PaymentCreateManyWithoutPeerInput {
  create: [PaymentCreateWithoutPeerInput!]
  connect: [PaymentWhereUniqueInput!]
}

input PaymentCreateManyWithoutStoryDataInput {
  create: [PaymentCreateWithoutStoryDataInput!]
  connect: [PaymentWhereUniqueInput!]
}

input PaymentCreateOneWithoutCommentsInput {
  create: PaymentCreateWithoutCommentsInput
  connect: PaymentWhereUniqueInput
}

input PaymentCreateWithoutAccountInput {
  postedOn: DateTime!
  amount: Float!
  peerName: String
  peerNameNormalized: String
  description: String
  descriptionNormalized: String
  rawData: Json!
  peer: PeerCreateOneWithoutPaymentsInput
  comments: CommentCreateManyWithoutPaymentInput
  category: CategoryCreateOneInput
  storyData: StoryDataCreateOneWithoutPaymentsInput
}

input PaymentCreateWithoutCommentsInput {
  postedOn: DateTime!
  amount: Float!
  peerName: String
  peerNameNormalized: String
  description: String
  descriptionNormalized: String
  rawData: Json!
  account: AccountCreateOneWithoutPaymentsInput!
  peer: PeerCreateOneWithoutPaymentsInput
  category: CategoryCreateOneInput
  storyData: StoryDataCreateOneWithoutPaymentsInput
}

input PaymentCreateWithoutPeerInput {
  postedOn: DateTime!
  amount: Float!
  peerName: String
  peerNameNormalized: String
  description: String
  descriptionNormalized: String
  rawData: Json!
  account: AccountCreateOneWithoutPaymentsInput!
  comments: CommentCreateManyWithoutPaymentInput
  category: CategoryCreateOneInput
  storyData: StoryDataCreateOneWithoutPaymentsInput
}

input PaymentCreateWithoutStoryDataInput {
  postedOn: DateTime!
  amount: Float!
  peerName: String
  peerNameNormalized: String
  description: String
  descriptionNormalized: String
  rawData: Json!
  account: AccountCreateOneWithoutPaymentsInput!
  peer: PeerCreateOneWithoutPaymentsInput
  comments: CommentCreateManyWithoutPaymentInput
  category: CategoryCreateOneInput
}

"""An edge in a connection."""
type PaymentEdge {
  """The item at the end of the edge."""
  node: Payment!

  """A cursor for use in pagination."""
  cursor: String!
}

enum PaymentOrderByInput {
  id_ASC
  id_DESC
  postedOn_ASC
  postedOn_DESC
  amount_ASC
  amount_DESC
  peerName_ASC
  peerName_DESC
  peerNameNormalized_ASC
  peerNameNormalized_DESC
  description_ASC
  description_DESC
  descriptionNormalized_ASC
  descriptionNormalized_DESC
  rawData_ASC
  rawData_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type PaymentPreviousValues {
  id: ID!
  postedOn: DateTime!
  amount: Float!
  peerName: String
  peerNameNormalized: String
  description: String
  descriptionNormalized: String
  rawData: Json!
}

type PaymentSubscriptionPayload {
  mutation: MutationType!
  node: Payment
  updatedFields: [String!]
  previousValues: PaymentPreviousValues
}

input PaymentSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [PaymentSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [PaymentSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [PaymentSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: PaymentWhereInput
}

input PaymentUpdateInput {
  postedOn: DateTime
  amount: Float
  peerName: String
  peerNameNormalized: String
  description: String
  descriptionNormalized: String
  rawData: Json
  account: AccountUpdateOneWithoutPaymentsInput
  peer: PeerUpdateOneWithoutPaymentsInput
  comments: CommentUpdateManyWithoutPaymentInput
  category: CategoryUpdateOneInput
  storyData: StoryDataUpdateOneWithoutPaymentsInput
}

input PaymentUpdateManyWithoutAccountInput {
  create: [PaymentCreateWithoutAccountInput!]
  connect: [PaymentWhereUniqueInput!]
  disconnect: [PaymentWhereUniqueInput!]
  delete: [PaymentWhereUniqueInput!]
  update: [PaymentUpdateWithWhereUniqueWithoutAccountInput!]
  upsert: [PaymentUpsertWithWhereUniqueWithoutAccountInput!]
}

input PaymentUpdateManyWithoutPeerInput {
  create: [PaymentCreateWithoutPeerInput!]
  connect: [PaymentWhereUniqueInput!]
  disconnect: [PaymentWhereUniqueInput!]
  delete: [PaymentWhereUniqueInput!]
  update: [PaymentUpdateWithWhereUniqueWithoutPeerInput!]
  upsert: [PaymentUpsertWithWhereUniqueWithoutPeerInput!]
}

input PaymentUpdateManyWithoutStoryDataInput {
  create: [PaymentCreateWithoutStoryDataInput!]
  connect: [PaymentWhereUniqueInput!]
  disconnect: [PaymentWhereUniqueInput!]
  delete: [PaymentWhereUniqueInput!]
  update: [PaymentUpdateWithWhereUniqueWithoutStoryDataInput!]
  upsert: [PaymentUpsertWithWhereUniqueWithoutStoryDataInput!]
}

input PaymentUpdateOneWithoutCommentsInput {
  create: PaymentCreateWithoutCommentsInput
  connect: PaymentWhereUniqueInput
  delete: Boolean
  update: PaymentUpdateWithoutCommentsDataInput
  upsert: PaymentUpsertWithoutCommentsInput
}

input PaymentUpdateWithoutAccountDataInput {
  postedOn: DateTime
  amount: Float
  peerName: String
  peerNameNormalized: String
  description: String
  descriptionNormalized: String
  rawData: Json
  peer: PeerUpdateOneWithoutPaymentsInput
  comments: CommentUpdateManyWithoutPaymentInput
  category: CategoryUpdateOneInput
  storyData: StoryDataUpdateOneWithoutPaymentsInput
}

input PaymentUpdateWithoutCommentsDataInput {
  postedOn: DateTime
  amount: Float
  peerName: String
  peerNameNormalized: String
  description: String
  descriptionNormalized: String
  rawData: Json
  account: AccountUpdateOneWithoutPaymentsInput
  peer: PeerUpdateOneWithoutPaymentsInput
  category: CategoryUpdateOneInput
  storyData: StoryDataUpdateOneWithoutPaymentsInput
}

input PaymentUpdateWithoutPeerDataInput {
  postedOn: DateTime
  amount: Float
  peerName: String
  peerNameNormalized: String
  description: String
  descriptionNormalized: String
  rawData: Json
  account: AccountUpdateOneWithoutPaymentsInput
  comments: CommentUpdateManyWithoutPaymentInput
  category: CategoryUpdateOneInput
  storyData: StoryDataUpdateOneWithoutPaymentsInput
}

input PaymentUpdateWithoutStoryDataDataInput {
  postedOn: DateTime
  amount: Float
  peerName: String
  peerNameNormalized: String
  description: String
  descriptionNormalized: String
  rawData: Json
  account: AccountUpdateOneWithoutPaymentsInput
  peer: PeerUpdateOneWithoutPaymentsInput
  comments: CommentUpdateManyWithoutPaymentInput
  category: CategoryUpdateOneInput
}

input PaymentUpdateWithWhereUniqueWithoutAccountInput {
  where: PaymentWhereUniqueInput!
  data: PaymentUpdateWithoutAccountDataInput!
}

input PaymentUpdateWithWhereUniqueWithoutPeerInput {
  where: PaymentWhereUniqueInput!
  data: PaymentUpdateWithoutPeerDataInput!
}

input PaymentUpdateWithWhereUniqueWithoutStoryDataInput {
  where: PaymentWhereUniqueInput!
  data: PaymentUpdateWithoutStoryDataDataInput!
}

input PaymentUpsertWithoutCommentsInput {
  update: PaymentUpdateWithoutCommentsDataInput!
  create: PaymentCreateWithoutCommentsInput!
}

input PaymentUpsertWithWhereUniqueWithoutAccountInput {
  where: PaymentWhereUniqueInput!
  update: PaymentUpdateWithoutAccountDataInput!
  create: PaymentCreateWithoutAccountInput!
}

input PaymentUpsertWithWhereUniqueWithoutPeerInput {
  where: PaymentWhereUniqueInput!
  update: PaymentUpdateWithoutPeerDataInput!
  create: PaymentCreateWithoutPeerInput!
}

input PaymentUpsertWithWhereUniqueWithoutStoryDataInput {
  where: PaymentWhereUniqueInput!
  update: PaymentUpdateWithoutStoryDataDataInput!
  create: PaymentCreateWithoutStoryDataInput!
}

input PaymentWhereInput {
  """Logical AND on all given filters."""
  AND: [PaymentWhereInput!]

  """Logical OR on all given filters."""
  OR: [PaymentWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [PaymentWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  postedOn: DateTime

  """All values that are not equal to given value."""
  postedOn_not: DateTime

  """All values that are contained in given list."""
  postedOn_in: [DateTime!]

  """All values that are not contained in given list."""
  postedOn_not_in: [DateTime!]

  """All values less than the given value."""
  postedOn_lt: DateTime

  """All values less than or equal the given value."""
  postedOn_lte: DateTime

  """All values greater than the given value."""
  postedOn_gt: DateTime

  """All values greater than or equal the given value."""
  postedOn_gte: DateTime
  amount: Float

  """All values that are not equal to given value."""
  amount_not: Float

  """All values that are contained in given list."""
  amount_in: [Float!]

  """All values that are not contained in given list."""
  amount_not_in: [Float!]

  """All values less than the given value."""
  amount_lt: Float

  """All values less than or equal the given value."""
  amount_lte: Float

  """All values greater than the given value."""
  amount_gt: Float

  """All values greater than or equal the given value."""
  amount_gte: Float
  peerName: String

  """All values that are not equal to given value."""
  peerName_not: String

  """All values that are contained in given list."""
  peerName_in: [String!]

  """All values that are not contained in given list."""
  peerName_not_in: [String!]

  """All values less than the given value."""
  peerName_lt: String

  """All values less than or equal the given value."""
  peerName_lte: String

  """All values greater than the given value."""
  peerName_gt: String

  """All values greater than or equal the given value."""
  peerName_gte: String

  """All values containing the given string."""
  peerName_contains: String

  """All values not containing the given string."""
  peerName_not_contains: String

  """All values starting with the given string."""
  peerName_starts_with: String

  """All values not starting with the given string."""
  peerName_not_starts_with: String

  """All values ending with the given string."""
  peerName_ends_with: String

  """All values not ending with the given string."""
  peerName_not_ends_with: String
  peerNameNormalized: String

  """All values that are not equal to given value."""
  peerNameNormalized_not: String

  """All values that are contained in given list."""
  peerNameNormalized_in: [String!]

  """All values that are not contained in given list."""
  peerNameNormalized_not_in: [String!]

  """All values less than the given value."""
  peerNameNormalized_lt: String

  """All values less than or equal the given value."""
  peerNameNormalized_lte: String

  """All values greater than the given value."""
  peerNameNormalized_gt: String

  """All values greater than or equal the given value."""
  peerNameNormalized_gte: String

  """All values containing the given string."""
  peerNameNormalized_contains: String

  """All values not containing the given string."""
  peerNameNormalized_not_contains: String

  """All values starting with the given string."""
  peerNameNormalized_starts_with: String

  """All values not starting with the given string."""
  peerNameNormalized_not_starts_with: String

  """All values ending with the given string."""
  peerNameNormalized_ends_with: String

  """All values not ending with the given string."""
  peerNameNormalized_not_ends_with: String
  description: String

  """All values that are not equal to given value."""
  description_not: String

  """All values that are contained in given list."""
  description_in: [String!]

  """All values that are not contained in given list."""
  description_not_in: [String!]

  """All values less than the given value."""
  description_lt: String

  """All values less than or equal the given value."""
  description_lte: String

  """All values greater than the given value."""
  description_gt: String

  """All values greater than or equal the given value."""
  description_gte: String

  """All values containing the given string."""
  description_contains: String

  """All values not containing the given string."""
  description_not_contains: String

  """All values starting with the given string."""
  description_starts_with: String

  """All values not starting with the given string."""
  description_not_starts_with: String

  """All values ending with the given string."""
  description_ends_with: String

  """All values not ending with the given string."""
  description_not_ends_with: String
  descriptionNormalized: String

  """All values that are not equal to given value."""
  descriptionNormalized_not: String

  """All values that are contained in given list."""
  descriptionNormalized_in: [String!]

  """All values that are not contained in given list."""
  descriptionNormalized_not_in: [String!]

  """All values less than the given value."""
  descriptionNormalized_lt: String

  """All values less than or equal the given value."""
  descriptionNormalized_lte: String

  """All values greater than the given value."""
  descriptionNormalized_gt: String

  """All values greater than or equal the given value."""
  descriptionNormalized_gte: String

  """All values containing the given string."""
  descriptionNormalized_contains: String

  """All values not containing the given string."""
  descriptionNormalized_not_contains: String

  """All values starting with the given string."""
  descriptionNormalized_starts_with: String

  """All values not starting with the given string."""
  descriptionNormalized_not_starts_with: String

  """All values ending with the given string."""
  descriptionNormalized_ends_with: String

  """All values not ending with the given string."""
  descriptionNormalized_not_ends_with: String
  account: AccountWhereInput
  peer: PeerWhereInput
  comments_every: CommentWhereInput
  comments_some: CommentWhereInput
  comments_none: CommentWhereInput
  category: CategoryWhereInput
  storyData: StoryDataWhereInput
}

input PaymentWhereUniqueInput {
  id: ID
}

type Peer implements Node {
  id: ID!
  account(where: AccountWhereInput): Account!
  name: String!
  nameNormalized: String
  total: Float!
  revenue: Float!
  spendings: Float!
  lastPaymentDate: DateTime
  payments(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Payment!]
  paymentCount: Int
  category(where: CategoryWhereInput): Category
  categories(where: PeerCategoryWhereInput, orderBy: PeerCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PeerCategory!]
}

type PeerCategory implements Node {
  id: ID!
  peer(where: PeerWhereInput): Peer!
  category(where: CategoryWhereInput): Category!
  count: Int!
  total: Float!
  revenue: Float!
  spendings: Float!
}

"""A connection to a list of items."""
type PeerCategoryConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [PeerCategoryEdge]!
  aggregate: AggregatePeerCategory!
}

input PeerCategoryCreateInput {
  count: Int!
  total: Float!
  revenue: Float!
  spendings: Float!
  peer: PeerCreateOneWithoutCategoriesInput!
  category: CategoryCreateOneWithoutPeersInput!
}

input PeerCategoryCreateManyWithoutCategoryInput {
  create: [PeerCategoryCreateWithoutCategoryInput!]
  connect: [PeerCategoryWhereUniqueInput!]
}

input PeerCategoryCreateManyWithoutPeerInput {
  create: [PeerCategoryCreateWithoutPeerInput!]
  connect: [PeerCategoryWhereUniqueInput!]
}

input PeerCategoryCreateWithoutCategoryInput {
  count: Int!
  total: Float!
  revenue: Float!
  spendings: Float!
  peer: PeerCreateOneWithoutCategoriesInput!
}

input PeerCategoryCreateWithoutPeerInput {
  count: Int!
  total: Float!
  revenue: Float!
  spendings: Float!
  category: CategoryCreateOneWithoutPeersInput!
}

"""An edge in a connection."""
type PeerCategoryEdge {
  """The item at the end of the edge."""
  node: PeerCategory!

  """A cursor for use in pagination."""
  cursor: String!
}

enum PeerCategoryOrderByInput {
  id_ASC
  id_DESC
  count_ASC
  count_DESC
  total_ASC
  total_DESC
  revenue_ASC
  revenue_DESC
  spendings_ASC
  spendings_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type PeerCategoryPreviousValues {
  id: ID!
  count: Int!
  total: Float!
  revenue: Float!
  spendings: Float!
}

type PeerCategorySubscriptionPayload {
  mutation: MutationType!
  node: PeerCategory
  updatedFields: [String!]
  previousValues: PeerCategoryPreviousValues
}

input PeerCategorySubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [PeerCategorySubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [PeerCategorySubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [PeerCategorySubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: PeerCategoryWhereInput
}

input PeerCategoryUpdateInput {
  count: Int
  total: Float
  revenue: Float
  spendings: Float
  peer: PeerUpdateOneWithoutCategoriesInput
  category: CategoryUpdateOneWithoutPeersInput
}

input PeerCategoryUpdateManyWithoutCategoryInput {
  create: [PeerCategoryCreateWithoutCategoryInput!]
  connect: [PeerCategoryWhereUniqueInput!]
  disconnect: [PeerCategoryWhereUniqueInput!]
  delete: [PeerCategoryWhereUniqueInput!]
  update: [PeerCategoryUpdateWithWhereUniqueWithoutCategoryInput!]
  upsert: [PeerCategoryUpsertWithWhereUniqueWithoutCategoryInput!]
}

input PeerCategoryUpdateManyWithoutPeerInput {
  create: [PeerCategoryCreateWithoutPeerInput!]
  connect: [PeerCategoryWhereUniqueInput!]
  disconnect: [PeerCategoryWhereUniqueInput!]
  delete: [PeerCategoryWhereUniqueInput!]
  update: [PeerCategoryUpdateWithWhereUniqueWithoutPeerInput!]
  upsert: [PeerCategoryUpsertWithWhereUniqueWithoutPeerInput!]
}

input PeerCategoryUpdateWithoutCategoryDataInput {
  count: Int
  total: Float
  revenue: Float
  spendings: Float
  peer: PeerUpdateOneWithoutCategoriesInput
}

input PeerCategoryUpdateWithoutPeerDataInput {
  count: Int
  total: Float
  revenue: Float
  spendings: Float
  category: CategoryUpdateOneWithoutPeersInput
}

input PeerCategoryUpdateWithWhereUniqueWithoutCategoryInput {
  where: PeerCategoryWhereUniqueInput!
  data: PeerCategoryUpdateWithoutCategoryDataInput!
}

input PeerCategoryUpdateWithWhereUniqueWithoutPeerInput {
  where: PeerCategoryWhereUniqueInput!
  data: PeerCategoryUpdateWithoutPeerDataInput!
}

input PeerCategoryUpsertWithWhereUniqueWithoutCategoryInput {
  where: PeerCategoryWhereUniqueInput!
  update: PeerCategoryUpdateWithoutCategoryDataInput!
  create: PeerCategoryCreateWithoutCategoryInput!
}

input PeerCategoryUpsertWithWhereUniqueWithoutPeerInput {
  where: PeerCategoryWhereUniqueInput!
  update: PeerCategoryUpdateWithoutPeerDataInput!
  create: PeerCategoryCreateWithoutPeerInput!
}

input PeerCategoryWhereInput {
  """Logical AND on all given filters."""
  AND: [PeerCategoryWhereInput!]

  """Logical OR on all given filters."""
  OR: [PeerCategoryWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [PeerCategoryWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  count: Int

  """All values that are not equal to given value."""
  count_not: Int

  """All values that are contained in given list."""
  count_in: [Int!]

  """All values that are not contained in given list."""
  count_not_in: [Int!]

  """All values less than the given value."""
  count_lt: Int

  """All values less than or equal the given value."""
  count_lte: Int

  """All values greater than the given value."""
  count_gt: Int

  """All values greater than or equal the given value."""
  count_gte: Int
  total: Float

  """All values that are not equal to given value."""
  total_not: Float

  """All values that are contained in given list."""
  total_in: [Float!]

  """All values that are not contained in given list."""
  total_not_in: [Float!]

  """All values less than the given value."""
  total_lt: Float

  """All values less than or equal the given value."""
  total_lte: Float

  """All values greater than the given value."""
  total_gt: Float

  """All values greater than or equal the given value."""
  total_gte: Float
  revenue: Float

  """All values that are not equal to given value."""
  revenue_not: Float

  """All values that are contained in given list."""
  revenue_in: [Float!]

  """All values that are not contained in given list."""
  revenue_not_in: [Float!]

  """All values less than the given value."""
  revenue_lt: Float

  """All values less than or equal the given value."""
  revenue_lte: Float

  """All values greater than the given value."""
  revenue_gt: Float

  """All values greater than or equal the given value."""
  revenue_gte: Float
  spendings: Float

  """All values that are not equal to given value."""
  spendings_not: Float

  """All values that are contained in given list."""
  spendings_in: [Float!]

  """All values that are not contained in given list."""
  spendings_not_in: [Float!]

  """All values less than the given value."""
  spendings_lt: Float

  """All values less than or equal the given value."""
  spendings_lte: Float

  """All values greater than the given value."""
  spendings_gt: Float

  """All values greater than or equal the given value."""
  spendings_gte: Float
  peer: PeerWhereInput
  category: CategoryWhereInput
}

input PeerCategoryWhereUniqueInput {
  id: ID
}

"""A connection to a list of items."""
type PeerConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [PeerEdge]!
  aggregate: AggregatePeer!
}

input PeerCreateInput {
  name: String!
  nameNormalized: String
  total: Float
  revenue: Float
  spendings: Float
  lastPaymentDate: DateTime
  paymentCount: Int
  account: AccountCreateOneWithoutPeersInput!
  payments: PaymentCreateManyWithoutPeerInput
  category: CategoryCreateOneInput
  categories: PeerCategoryCreateManyWithoutPeerInput
}

input PeerCreateManyWithoutAccountInput {
  create: [PeerCreateWithoutAccountInput!]
  connect: [PeerWhereUniqueInput!]
}

input PeerCreateOneWithoutCategoriesInput {
  create: PeerCreateWithoutCategoriesInput
  connect: PeerWhereUniqueInput
}

input PeerCreateOneWithoutPaymentsInput {
  create: PeerCreateWithoutPaymentsInput
  connect: PeerWhereUniqueInput
}

input PeerCreateWithoutAccountInput {
  name: String!
  nameNormalized: String
  total: Float
  revenue: Float
  spendings: Float
  lastPaymentDate: DateTime
  paymentCount: Int
  payments: PaymentCreateManyWithoutPeerInput
  category: CategoryCreateOneInput
  categories: PeerCategoryCreateManyWithoutPeerInput
}

input PeerCreateWithoutCategoriesInput {
  name: String!
  nameNormalized: String
  total: Float
  revenue: Float
  spendings: Float
  lastPaymentDate: DateTime
  paymentCount: Int
  account: AccountCreateOneWithoutPeersInput!
  payments: PaymentCreateManyWithoutPeerInput
  category: CategoryCreateOneInput
}

input PeerCreateWithoutPaymentsInput {
  name: String!
  nameNormalized: String
  total: Float
  revenue: Float
  spendings: Float
  lastPaymentDate: DateTime
  paymentCount: Int
  account: AccountCreateOneWithoutPeersInput!
  category: CategoryCreateOneInput
  categories: PeerCategoryCreateManyWithoutPeerInput
}

"""An edge in a connection."""
type PeerEdge {
  """The item at the end of the edge."""
  node: Peer!

  """A cursor for use in pagination."""
  cursor: String!
}

enum PeerOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  nameNormalized_ASC
  nameNormalized_DESC
  total_ASC
  total_DESC
  revenue_ASC
  revenue_DESC
  spendings_ASC
  spendings_DESC
  lastPaymentDate_ASC
  lastPaymentDate_DESC
  paymentCount_ASC
  paymentCount_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type PeerPreviousValues {
  id: ID!
  name: String!
  nameNormalized: String
  total: Float!
  revenue: Float!
  spendings: Float!
  lastPaymentDate: DateTime
  paymentCount: Int
}

type PeerSubscriptionPayload {
  mutation: MutationType!
  node: Peer
  updatedFields: [String!]
  previousValues: PeerPreviousValues
}

input PeerSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [PeerSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [PeerSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [PeerSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: PeerWhereInput
}

input PeerUpdateInput {
  name: String
  nameNormalized: String
  total: Float
  revenue: Float
  spendings: Float
  lastPaymentDate: DateTime
  paymentCount: Int
  account: AccountUpdateOneWithoutPeersInput
  payments: PaymentUpdateManyWithoutPeerInput
  category: CategoryUpdateOneInput
  categories: PeerCategoryUpdateManyWithoutPeerInput
}

input PeerUpdateManyWithoutAccountInput {
  create: [PeerCreateWithoutAccountInput!]
  connect: [PeerWhereUniqueInput!]
  disconnect: [PeerWhereUniqueInput!]
  delete: [PeerWhereUniqueInput!]
  update: [PeerUpdateWithWhereUniqueWithoutAccountInput!]
  upsert: [PeerUpsertWithWhereUniqueWithoutAccountInput!]
}

input PeerUpdateOneWithoutCategoriesInput {
  create: PeerCreateWithoutCategoriesInput
  connect: PeerWhereUniqueInput
  delete: Boolean
  update: PeerUpdateWithoutCategoriesDataInput
  upsert: PeerUpsertWithoutCategoriesInput
}

input PeerUpdateOneWithoutPaymentsInput {
  create: PeerCreateWithoutPaymentsInput
  connect: PeerWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: PeerUpdateWithoutPaymentsDataInput
  upsert: PeerUpsertWithoutPaymentsInput
}

input PeerUpdateWithoutAccountDataInput {
  name: String
  nameNormalized: String
  total: Float
  revenue: Float
  spendings: Float
  lastPaymentDate: DateTime
  paymentCount: Int
  payments: PaymentUpdateManyWithoutPeerInput
  category: CategoryUpdateOneInput
  categories: PeerCategoryUpdateManyWithoutPeerInput
}

input PeerUpdateWithoutCategoriesDataInput {
  name: String
  nameNormalized: String
  total: Float
  revenue: Float
  spendings: Float
  lastPaymentDate: DateTime
  paymentCount: Int
  account: AccountUpdateOneWithoutPeersInput
  payments: PaymentUpdateManyWithoutPeerInput
  category: CategoryUpdateOneInput
}

input PeerUpdateWithoutPaymentsDataInput {
  name: String
  nameNormalized: String
  total: Float
  revenue: Float
  spendings: Float
  lastPaymentDate: DateTime
  paymentCount: Int
  account: AccountUpdateOneWithoutPeersInput
  category: CategoryUpdateOneInput
  categories: PeerCategoryUpdateManyWithoutPeerInput
}

input PeerUpdateWithWhereUniqueWithoutAccountInput {
  where: PeerWhereUniqueInput!
  data: PeerUpdateWithoutAccountDataInput!
}

input PeerUpsertWithoutCategoriesInput {
  update: PeerUpdateWithoutCategoriesDataInput!
  create: PeerCreateWithoutCategoriesInput!
}

input PeerUpsertWithoutPaymentsInput {
  update: PeerUpdateWithoutPaymentsDataInput!
  create: PeerCreateWithoutPaymentsInput!
}

input PeerUpsertWithWhereUniqueWithoutAccountInput {
  where: PeerWhereUniqueInput!
  update: PeerUpdateWithoutAccountDataInput!
  create: PeerCreateWithoutAccountInput!
}

input PeerWhereInput {
  """Logical AND on all given filters."""
  AND: [PeerWhereInput!]

  """Logical OR on all given filters."""
  OR: [PeerWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [PeerWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  nameNormalized: String

  """All values that are not equal to given value."""
  nameNormalized_not: String

  """All values that are contained in given list."""
  nameNormalized_in: [String!]

  """All values that are not contained in given list."""
  nameNormalized_not_in: [String!]

  """All values less than the given value."""
  nameNormalized_lt: String

  """All values less than or equal the given value."""
  nameNormalized_lte: String

  """All values greater than the given value."""
  nameNormalized_gt: String

  """All values greater than or equal the given value."""
  nameNormalized_gte: String

  """All values containing the given string."""
  nameNormalized_contains: String

  """All values not containing the given string."""
  nameNormalized_not_contains: String

  """All values starting with the given string."""
  nameNormalized_starts_with: String

  """All values not starting with the given string."""
  nameNormalized_not_starts_with: String

  """All values ending with the given string."""
  nameNormalized_ends_with: String

  """All values not ending with the given string."""
  nameNormalized_not_ends_with: String
  total: Float

  """All values that are not equal to given value."""
  total_not: Float

  """All values that are contained in given list."""
  total_in: [Float!]

  """All values that are not contained in given list."""
  total_not_in: [Float!]

  """All values less than the given value."""
  total_lt: Float

  """All values less than or equal the given value."""
  total_lte: Float

  """All values greater than the given value."""
  total_gt: Float

  """All values greater than or equal the given value."""
  total_gte: Float
  revenue: Float

  """All values that are not equal to given value."""
  revenue_not: Float

  """All values that are contained in given list."""
  revenue_in: [Float!]

  """All values that are not contained in given list."""
  revenue_not_in: [Float!]

  """All values less than the given value."""
  revenue_lt: Float

  """All values less than or equal the given value."""
  revenue_lte: Float

  """All values greater than the given value."""
  revenue_gt: Float

  """All values greater than or equal the given value."""
  revenue_gte: Float
  spendings: Float

  """All values that are not equal to given value."""
  spendings_not: Float

  """All values that are contained in given list."""
  spendings_in: [Float!]

  """All values that are not contained in given list."""
  spendings_not_in: [Float!]

  """All values less than the given value."""
  spendings_lt: Float

  """All values less than or equal the given value."""
  spendings_lte: Float

  """All values greater than the given value."""
  spendings_gt: Float

  """All values greater than or equal the given value."""
  spendings_gte: Float
  lastPaymentDate: DateTime

  """All values that are not equal to given value."""
  lastPaymentDate_not: DateTime

  """All values that are contained in given list."""
  lastPaymentDate_in: [DateTime!]

  """All values that are not contained in given list."""
  lastPaymentDate_not_in: [DateTime!]

  """All values less than the given value."""
  lastPaymentDate_lt: DateTime

  """All values less than or equal the given value."""
  lastPaymentDate_lte: DateTime

  """All values greater than the given value."""
  lastPaymentDate_gt: DateTime

  """All values greater than or equal the given value."""
  lastPaymentDate_gte: DateTime
  paymentCount: Int

  """All values that are not equal to given value."""
  paymentCount_not: Int

  """All values that are contained in given list."""
  paymentCount_in: [Int!]

  """All values that are not contained in given list."""
  paymentCount_not_in: [Int!]

  """All values less than the given value."""
  paymentCount_lt: Int

  """All values less than or equal the given value."""
  paymentCount_lte: Int

  """All values greater than the given value."""
  paymentCount_gt: Int

  """All values greater than or equal the given value."""
  paymentCount_gte: Int
  account: AccountWhereInput
  payments_every: PaymentWhereInput
  payments_some: PaymentWhereInput
  payments_none: PaymentWhereInput
  category: CategoryWhereInput
  categories_every: PeerCategoryWhereInput
  categories_some: PeerCategoryWhereInput
  categories_none: PeerCategoryWhereInput
}

input PeerWhereUniqueInput {
  id: ID
}

type Query {
  teams(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Team]!
  teamMembers(where: TeamMemberWhereInput, orderBy: TeamMemberOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TeamMember]!
  accounts(where: AccountWhereInput, orderBy: AccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Account]!
  teamMemberAccounts(where: TeamMemberAccountWhereInput, orderBy: TeamMemberAccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TeamMemberAccount]!
  payments(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Payment]!
  peers(where: PeerWhereInput, orderBy: PeerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Peer]!
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment]!
  peerCategories(where: PeerCategoryWhereInput, orderBy: PeerCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PeerCategory]!
  stories(where: StoryWhereInput, orderBy: StoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Story]!
  storyDatas(where: StoryDataWhereInput, orderBy: StoryDataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [StoryData]!
  onboardings(where: OnboardingWhereInput, orderBy: OnboardingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Onboarding]!
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  categories(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Category]!
  team(where: TeamWhereUniqueInput!): Team
  teamMember(where: TeamMemberWhereUniqueInput!): TeamMember
  account(where: AccountWhereUniqueInput!): Account
  teamMemberAccount(where: TeamMemberAccountWhereUniqueInput!): TeamMemberAccount
  payment(where: PaymentWhereUniqueInput!): Payment
  peer(where: PeerWhereUniqueInput!): Peer
  comment(where: CommentWhereUniqueInput!): Comment
  peerCategory(where: PeerCategoryWhereUniqueInput!): PeerCategory
  story(where: StoryWhereUniqueInput!): Story
  onboarding(where: OnboardingWhereUniqueInput!): Onboarding
  user(where: UserWhereUniqueInput!): User
  category(where: CategoryWhereUniqueInput!): Category
  teamsConnection(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TeamConnection!
  teamMembersConnection(where: TeamMemberWhereInput, orderBy: TeamMemberOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TeamMemberConnection!
  accountsConnection(where: AccountWhereInput, orderBy: AccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AccountConnection!
  teamMemberAccountsConnection(where: TeamMemberAccountWhereInput, orderBy: TeamMemberAccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TeamMemberAccountConnection!
  paymentsConnection(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PaymentConnection!
  peersConnection(where: PeerWhereInput, orderBy: PeerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PeerConnection!
  commentsConnection(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CommentConnection!
  peerCategoriesConnection(where: PeerCategoryWhereInput, orderBy: PeerCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PeerCategoryConnection!
  storiesConnection(where: StoryWhereInput, orderBy: StoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StoryConnection!
  storyDatasConnection(where: StoryDataWhereInput, orderBy: StoryDataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StoryDataConnection!
  onboardingsConnection(where: OnboardingWhereInput, orderBy: OnboardingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OnboardingConnection!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  categoriesConnection(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CategoryConnection!

  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node
}

type Story implements Node {
  id: ID!
  account(where: AccountWhereInput): Account!
  draftData(where: StoryDataWhereInput): StoryData!
  publicData(where: StoryDataWhereInput): StoryData
  isPublished: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""A connection to a list of items."""
type StoryConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [StoryEdge]!
  aggregate: AggregateStory!
}

input StoryCreateInput {
  isPublished: Boolean
  account: AccountCreateOneWithoutStoriesInput!
  draftData: StoryDataCreateOneWithoutDraftStoryInput!
  publicData: StoryDataCreateOneWithoutPublicStoryInput
}

input StoryCreateManyWithoutAccountInput {
  create: [StoryCreateWithoutAccountInput!]
  connect: [StoryWhereUniqueInput!]
}

input StoryCreateOneWithoutDraftDataInput {
  create: StoryCreateWithoutDraftDataInput
  connect: StoryWhereUniqueInput
}

input StoryCreateOneWithoutPublicDataInput {
  create: StoryCreateWithoutPublicDataInput
  connect: StoryWhereUniqueInput
}

input StoryCreateWithoutAccountInput {
  isPublished: Boolean
  draftData: StoryDataCreateOneWithoutDraftStoryInput!
  publicData: StoryDataCreateOneWithoutPublicStoryInput
}

input StoryCreateWithoutDraftDataInput {
  isPublished: Boolean
  account: AccountCreateOneWithoutStoriesInput!
  publicData: StoryDataCreateOneWithoutPublicStoryInput
}

input StoryCreateWithoutPublicDataInput {
  isPublished: Boolean
  account: AccountCreateOneWithoutStoriesInput!
  draftData: StoryDataCreateOneWithoutDraftStoryInput!
}

type StoryData {
  title: String!
  body: Json!
  coverImage: Json
  payments(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Payment!]
  draftStory(where: StoryWhereInput): Story
  publicStory(where: StoryWhereInput): Story
}

"""A connection to a list of items."""
type StoryDataConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [StoryDataEdge]!
  aggregate: AggregateStoryData!
}

input StoryDataCreateInput {
  title: String!
  body: Json!
  coverImage: Json
  payments: PaymentCreateManyWithoutStoryDataInput
  draftStory: StoryCreateOneWithoutDraftDataInput
  publicStory: StoryCreateOneWithoutPublicDataInput
}

input StoryDataCreateOneWithoutDraftStoryInput {
  create: StoryDataCreateWithoutDraftStoryInput
}

input StoryDataCreateOneWithoutPaymentsInput {
  create: StoryDataCreateWithoutPaymentsInput
}

input StoryDataCreateOneWithoutPublicStoryInput {
  create: StoryDataCreateWithoutPublicStoryInput
}

input StoryDataCreateWithoutDraftStoryInput {
  title: String!
  body: Json!
  coverImage: Json
  payments: PaymentCreateManyWithoutStoryDataInput
  publicStory: StoryCreateOneWithoutPublicDataInput
}

input StoryDataCreateWithoutPaymentsInput {
  title: String!
  body: Json!
  coverImage: Json
  draftStory: StoryCreateOneWithoutDraftDataInput
  publicStory: StoryCreateOneWithoutPublicDataInput
}

input StoryDataCreateWithoutPublicStoryInput {
  title: String!
  body: Json!
  coverImage: Json
  payments: PaymentCreateManyWithoutStoryDataInput
  draftStory: StoryCreateOneWithoutDraftDataInput
}

"""An edge in a connection."""
type StoryDataEdge {
  """The item at the end of the edge."""
  node: StoryData!

  """A cursor for use in pagination."""
  cursor: String!
}

enum StoryDataOrderByInput {
  title_ASC
  title_DESC
  body_ASC
  body_DESC
  coverImage_ASC
  coverImage_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type StoryDataPreviousValues {
  title: String!
  body: Json!
  coverImage: Json
}

type StoryDataSubscriptionPayload {
  mutation: MutationType!
  node: StoryData
  updatedFields: [String!]
  previousValues: StoryDataPreviousValues
}

input StoryDataSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [StoryDataSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [StoryDataSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [StoryDataSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: StoryDataWhereInput
}

input StoryDataUpdateInput {
  title: String
  body: Json
  coverImage: Json
  payments: PaymentUpdateManyWithoutStoryDataInput
  draftStory: StoryUpdateOneWithoutDraftDataInput
  publicStory: StoryUpdateOneWithoutPublicDataInput
}

input StoryDataUpdateOneWithoutDraftStoryInput {
  create: StoryDataCreateWithoutDraftStoryInput
  delete: Boolean
  update: StoryDataUpdateWithoutDraftStoryDataInput
  upsert: StoryDataUpsertWithoutDraftStoryInput
}

input StoryDataUpdateOneWithoutPaymentsInput {
  create: StoryDataCreateWithoutPaymentsInput
  disconnect: Boolean
  delete: Boolean
  update: StoryDataUpdateWithoutPaymentsDataInput
  upsert: StoryDataUpsertWithoutPaymentsInput
}

input StoryDataUpdateOneWithoutPublicStoryInput {
  create: StoryDataCreateWithoutPublicStoryInput
  disconnect: Boolean
  delete: Boolean
  update: StoryDataUpdateWithoutPublicStoryDataInput
  upsert: StoryDataUpsertWithoutPublicStoryInput
}

input StoryDataUpdateWithoutDraftStoryDataInput {
  title: String
  body: Json
  coverImage: Json
  payments: PaymentUpdateManyWithoutStoryDataInput
  publicStory: StoryUpdateOneWithoutPublicDataInput
}

input StoryDataUpdateWithoutPaymentsDataInput {
  title: String
  body: Json
  coverImage: Json
  draftStory: StoryUpdateOneWithoutDraftDataInput
  publicStory: StoryUpdateOneWithoutPublicDataInput
}

input StoryDataUpdateWithoutPublicStoryDataInput {
  title: String
  body: Json
  coverImage: Json
  payments: PaymentUpdateManyWithoutStoryDataInput
  draftStory: StoryUpdateOneWithoutDraftDataInput
}

input StoryDataUpsertWithoutDraftStoryInput {
  update: StoryDataUpdateWithoutDraftStoryDataInput!
  create: StoryDataCreateWithoutDraftStoryInput!
}

input StoryDataUpsertWithoutPaymentsInput {
  update: StoryDataUpdateWithoutPaymentsDataInput!
  create: StoryDataCreateWithoutPaymentsInput!
}

input StoryDataUpsertWithoutPublicStoryInput {
  update: StoryDataUpdateWithoutPublicStoryDataInput!
  create: StoryDataCreateWithoutPublicStoryInput!
}

input StoryDataWhereInput {
  """Logical AND on all given filters."""
  AND: [StoryDataWhereInput!]

  """Logical OR on all given filters."""
  OR: [StoryDataWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [StoryDataWhereInput!]
  title: String

  """All values that are not equal to given value."""
  title_not: String

  """All values that are contained in given list."""
  title_in: [String!]

  """All values that are not contained in given list."""
  title_not_in: [String!]

  """All values less than the given value."""
  title_lt: String

  """All values less than or equal the given value."""
  title_lte: String

  """All values greater than the given value."""
  title_gt: String

  """All values greater than or equal the given value."""
  title_gte: String

  """All values containing the given string."""
  title_contains: String

  """All values not containing the given string."""
  title_not_contains: String

  """All values starting with the given string."""
  title_starts_with: String

  """All values not starting with the given string."""
  title_not_starts_with: String

  """All values ending with the given string."""
  title_ends_with: String

  """All values not ending with the given string."""
  title_not_ends_with: String
  payments_every: PaymentWhereInput
  payments_some: PaymentWhereInput
  payments_none: PaymentWhereInput
  draftStory: StoryWhereInput
  publicStory: StoryWhereInput
}

"""An edge in a connection."""
type StoryEdge {
  """The item at the end of the edge."""
  node: Story!

  """A cursor for use in pagination."""
  cursor: String!
}

enum StoryOrderByInput {
  id_ASC
  id_DESC
  isPublished_ASC
  isPublished_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type StoryPreviousValues {
  id: ID!
  isPublished: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type StorySubscriptionPayload {
  mutation: MutationType!
  node: Story
  updatedFields: [String!]
  previousValues: StoryPreviousValues
}

input StorySubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [StorySubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [StorySubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [StorySubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: StoryWhereInput
}

input StoryUpdateInput {
  isPublished: Boolean
  account: AccountUpdateOneWithoutStoriesInput
  draftData: StoryDataUpdateOneWithoutDraftStoryInput
  publicData: StoryDataUpdateOneWithoutPublicStoryInput
}

input StoryUpdateManyWithoutAccountInput {
  create: [StoryCreateWithoutAccountInput!]
  connect: [StoryWhereUniqueInput!]
  disconnect: [StoryWhereUniqueInput!]
  delete: [StoryWhereUniqueInput!]
  update: [StoryUpdateWithWhereUniqueWithoutAccountInput!]
  upsert: [StoryUpsertWithWhereUniqueWithoutAccountInput!]
}

input StoryUpdateOneWithoutDraftDataInput {
  create: StoryCreateWithoutDraftDataInput
  connect: StoryWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: StoryUpdateWithoutDraftDataDataInput
  upsert: StoryUpsertWithoutDraftDataInput
}

input StoryUpdateOneWithoutPublicDataInput {
  create: StoryCreateWithoutPublicDataInput
  connect: StoryWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: StoryUpdateWithoutPublicDataDataInput
  upsert: StoryUpsertWithoutPublicDataInput
}

input StoryUpdateWithoutAccountDataInput {
  isPublished: Boolean
  draftData: StoryDataUpdateOneWithoutDraftStoryInput
  publicData: StoryDataUpdateOneWithoutPublicStoryInput
}

input StoryUpdateWithoutDraftDataDataInput {
  isPublished: Boolean
  account: AccountUpdateOneWithoutStoriesInput
  publicData: StoryDataUpdateOneWithoutPublicStoryInput
}

input StoryUpdateWithoutPublicDataDataInput {
  isPublished: Boolean
  account: AccountUpdateOneWithoutStoriesInput
  draftData: StoryDataUpdateOneWithoutDraftStoryInput
}

input StoryUpdateWithWhereUniqueWithoutAccountInput {
  where: StoryWhereUniqueInput!
  data: StoryUpdateWithoutAccountDataInput!
}

input StoryUpsertWithoutDraftDataInput {
  update: StoryUpdateWithoutDraftDataDataInput!
  create: StoryCreateWithoutDraftDataInput!
}

input StoryUpsertWithoutPublicDataInput {
  update: StoryUpdateWithoutPublicDataDataInput!
  create: StoryCreateWithoutPublicDataInput!
}

input StoryUpsertWithWhereUniqueWithoutAccountInput {
  where: StoryWhereUniqueInput!
  update: StoryUpdateWithoutAccountDataInput!
  create: StoryCreateWithoutAccountInput!
}

input StoryWhereInput {
  """Logical AND on all given filters."""
  AND: [StoryWhereInput!]

  """Logical OR on all given filters."""
  OR: [StoryWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [StoryWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  isPublished: Boolean

  """All values that are not equal to given value."""
  isPublished_not: Boolean
  createdAt: DateTime

  """All values that are not equal to given value."""
  createdAt_not: DateTime

  """All values that are contained in given list."""
  createdAt_in: [DateTime!]

  """All values that are not contained in given list."""
  createdAt_not_in: [DateTime!]

  """All values less than the given value."""
  createdAt_lt: DateTime

  """All values less than or equal the given value."""
  createdAt_lte: DateTime

  """All values greater than the given value."""
  createdAt_gt: DateTime

  """All values greater than or equal the given value."""
  createdAt_gte: DateTime
  updatedAt: DateTime

  """All values that are not equal to given value."""
  updatedAt_not: DateTime

  """All values that are contained in given list."""
  updatedAt_in: [DateTime!]

  """All values that are not contained in given list."""
  updatedAt_not_in: [DateTime!]

  """All values less than the given value."""
  updatedAt_lt: DateTime

  """All values less than or equal the given value."""
  updatedAt_lte: DateTime

  """All values greater than the given value."""
  updatedAt_gt: DateTime

  """All values greater than or equal the given value."""
  updatedAt_gte: DateTime
  account: AccountWhereInput
  draftData: StoryDataWhereInput
  publicData: StoryDataWhereInput
}

input StoryWhereUniqueInput {
  id: ID
}

type Subscription {
  team(where: TeamSubscriptionWhereInput): TeamSubscriptionPayload
  teamMember(where: TeamMemberSubscriptionWhereInput): TeamMemberSubscriptionPayload
  account(where: AccountSubscriptionWhereInput): AccountSubscriptionPayload
  teamMemberAccount(where: TeamMemberAccountSubscriptionWhereInput): TeamMemberAccountSubscriptionPayload
  payment(where: PaymentSubscriptionWhereInput): PaymentSubscriptionPayload
  peer(where: PeerSubscriptionWhereInput): PeerSubscriptionPayload
  comment(where: CommentSubscriptionWhereInput): CommentSubscriptionPayload
  peerCategory(where: PeerCategorySubscriptionWhereInput): PeerCategorySubscriptionPayload
  story(where: StorySubscriptionWhereInput): StorySubscriptionPayload
  storyData(where: StoryDataSubscriptionWhereInput): StoryDataSubscriptionPayload
  onboarding(where: OnboardingSubscriptionWhereInput): OnboardingSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  category(where: CategorySubscriptionWhereInput): CategorySubscriptionPayload
}

type Team implements Node {
  id: ID!
  name: String!
  nameNormalized: String
  accounts(where: AccountWhereInput, orderBy: AccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Account!]
  members(where: TeamMemberWhereInput, orderBy: TeamMemberOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TeamMember!]
}

"""A connection to a list of items."""
type TeamConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [TeamEdge]!
  aggregate: AggregateTeam!
}

input TeamCreateInput {
  name: String!
  nameNormalized: String
  accounts: AccountCreateManyWithoutTeamInput
  members: TeamMemberCreateManyWithoutTeamInput
}

input TeamCreateOneWithoutAccountsInput {
  create: TeamCreateWithoutAccountsInput
  connect: TeamWhereUniqueInput
}

input TeamCreateOneWithoutMembersInput {
  create: TeamCreateWithoutMembersInput
  connect: TeamWhereUniqueInput
}

input TeamCreateWithoutAccountsInput {
  name: String!
  nameNormalized: String
  members: TeamMemberCreateManyWithoutTeamInput
}

input TeamCreateWithoutMembersInput {
  name: String!
  nameNormalized: String
  accounts: AccountCreateManyWithoutTeamInput
}

"""An edge in a connection."""
type TeamEdge {
  """The item at the end of the edge."""
  node: Team!

  """A cursor for use in pagination."""
  cursor: String!
}

type TeamMember implements Node {
  id: ID!
  team(where: TeamWhereInput): Team!
  user(where: UserWhereInput): User!
  role: TeamMemberRole!
  canInvite: Boolean!
  accounts(where: TeamMemberAccountWhereInput, orderBy: TeamMemberAccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TeamMemberAccount!]
}

type TeamMemberAccount implements Node {
  id: ID!
  teamMember(where: TeamMemberWhereInput): TeamMember!
  account(where: AccountWhereInput): Account!
}

"""A connection to a list of items."""
type TeamMemberAccountConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [TeamMemberAccountEdge]!
  aggregate: AggregateTeamMemberAccount!
}

input TeamMemberAccountCreateInput {
  teamMember: TeamMemberCreateOneWithoutAccountsInput!
  account: AccountCreateOneWithoutMembersInput!
}

input TeamMemberAccountCreateManyWithoutAccountInput {
  create: [TeamMemberAccountCreateWithoutAccountInput!]
  connect: [TeamMemberAccountWhereUniqueInput!]
}

input TeamMemberAccountCreateManyWithoutTeamMemberInput {
  create: [TeamMemberAccountCreateWithoutTeamMemberInput!]
  connect: [TeamMemberAccountWhereUniqueInput!]
}

input TeamMemberAccountCreateWithoutAccountInput {
  teamMember: TeamMemberCreateOneWithoutAccountsInput!
}

input TeamMemberAccountCreateWithoutTeamMemberInput {
  account: AccountCreateOneWithoutMembersInput!
}

"""An edge in a connection."""
type TeamMemberAccountEdge {
  """The item at the end of the edge."""
  node: TeamMemberAccount!

  """A cursor for use in pagination."""
  cursor: String!
}

enum TeamMemberAccountOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type TeamMemberAccountPreviousValues {
  id: ID!
}

type TeamMemberAccountSubscriptionPayload {
  mutation: MutationType!
  node: TeamMemberAccount
  updatedFields: [String!]
  previousValues: TeamMemberAccountPreviousValues
}

input TeamMemberAccountSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [TeamMemberAccountSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [TeamMemberAccountSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [TeamMemberAccountSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: TeamMemberAccountWhereInput
}

input TeamMemberAccountUpdateInput {
  teamMember: TeamMemberUpdateOneWithoutAccountsInput
  account: AccountUpdateOneWithoutMembersInput
}

input TeamMemberAccountUpdateManyWithoutAccountInput {
  create: [TeamMemberAccountCreateWithoutAccountInput!]
  connect: [TeamMemberAccountWhereUniqueInput!]
  disconnect: [TeamMemberAccountWhereUniqueInput!]
  delete: [TeamMemberAccountWhereUniqueInput!]
  update: [TeamMemberAccountUpdateWithWhereUniqueWithoutAccountInput!]
  upsert: [TeamMemberAccountUpsertWithWhereUniqueWithoutAccountInput!]
}

input TeamMemberAccountUpdateManyWithoutTeamMemberInput {
  create: [TeamMemberAccountCreateWithoutTeamMemberInput!]
  connect: [TeamMemberAccountWhereUniqueInput!]
  disconnect: [TeamMemberAccountWhereUniqueInput!]
  delete: [TeamMemberAccountWhereUniqueInput!]
  update: [TeamMemberAccountUpdateWithWhereUniqueWithoutTeamMemberInput!]
  upsert: [TeamMemberAccountUpsertWithWhereUniqueWithoutTeamMemberInput!]
}

input TeamMemberAccountUpdateWithoutAccountDataInput {
  teamMember: TeamMemberUpdateOneWithoutAccountsInput
}

input TeamMemberAccountUpdateWithoutTeamMemberDataInput {
  account: AccountUpdateOneWithoutMembersInput
}

input TeamMemberAccountUpdateWithWhereUniqueWithoutAccountInput {
  where: TeamMemberAccountWhereUniqueInput!
  data: TeamMemberAccountUpdateWithoutAccountDataInput!
}

input TeamMemberAccountUpdateWithWhereUniqueWithoutTeamMemberInput {
  where: TeamMemberAccountWhereUniqueInput!
  data: TeamMemberAccountUpdateWithoutTeamMemberDataInput!
}

input TeamMemberAccountUpsertWithWhereUniqueWithoutAccountInput {
  where: TeamMemberAccountWhereUniqueInput!
  update: TeamMemberAccountUpdateWithoutAccountDataInput!
  create: TeamMemberAccountCreateWithoutAccountInput!
}

input TeamMemberAccountUpsertWithWhereUniqueWithoutTeamMemberInput {
  where: TeamMemberAccountWhereUniqueInput!
  update: TeamMemberAccountUpdateWithoutTeamMemberDataInput!
  create: TeamMemberAccountCreateWithoutTeamMemberInput!
}

input TeamMemberAccountWhereInput {
  """Logical AND on all given filters."""
  AND: [TeamMemberAccountWhereInput!]

  """Logical OR on all given filters."""
  OR: [TeamMemberAccountWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [TeamMemberAccountWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  teamMember: TeamMemberWhereInput
  account: AccountWhereInput
}

input TeamMemberAccountWhereUniqueInput {
  id: ID
}

"""A connection to a list of items."""
type TeamMemberConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [TeamMemberEdge]!
  aggregate: AggregateTeamMember!
}

input TeamMemberCreateInput {
  role: TeamMemberRole
  canInvite: Boolean
  team: TeamCreateOneWithoutMembersInput!
  user: UserCreateOneWithoutTeamsInput!
  accounts: TeamMemberAccountCreateManyWithoutTeamMemberInput
}

input TeamMemberCreateManyWithoutTeamInput {
  create: [TeamMemberCreateWithoutTeamInput!]
  connect: [TeamMemberWhereUniqueInput!]
}

input TeamMemberCreateManyWithoutUserInput {
  create: [TeamMemberCreateWithoutUserInput!]
  connect: [TeamMemberWhereUniqueInput!]
}

input TeamMemberCreateOneWithoutAccountsInput {
  create: TeamMemberCreateWithoutAccountsInput
  connect: TeamMemberWhereUniqueInput
}

input TeamMemberCreateWithoutAccountsInput {
  role: TeamMemberRole
  canInvite: Boolean
  team: TeamCreateOneWithoutMembersInput!
  user: UserCreateOneWithoutTeamsInput!
}

input TeamMemberCreateWithoutTeamInput {
  role: TeamMemberRole
  canInvite: Boolean
  user: UserCreateOneWithoutTeamsInput!
  accounts: TeamMemberAccountCreateManyWithoutTeamMemberInput
}

input TeamMemberCreateWithoutUserInput {
  role: TeamMemberRole
  canInvite: Boolean
  team: TeamCreateOneWithoutMembersInput!
  accounts: TeamMemberAccountCreateManyWithoutTeamMemberInput
}

"""An edge in a connection."""
type TeamMemberEdge {
  """The item at the end of the edge."""
  node: TeamMember!

  """A cursor for use in pagination."""
  cursor: String!
}

enum TeamMemberOrderByInput {
  id_ASC
  id_DESC
  role_ASC
  role_DESC
  canInvite_ASC
  canInvite_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type TeamMemberPreviousValues {
  id: ID!
  role: TeamMemberRole!
  canInvite: Boolean!
}

enum TeamMemberRole {
  ADMIN
  MANAGER
  MEMBER
}

type TeamMemberSubscriptionPayload {
  mutation: MutationType!
  node: TeamMember
  updatedFields: [String!]
  previousValues: TeamMemberPreviousValues
}

input TeamMemberSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [TeamMemberSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [TeamMemberSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [TeamMemberSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: TeamMemberWhereInput
}

input TeamMemberUpdateInput {
  role: TeamMemberRole
  canInvite: Boolean
  team: TeamUpdateOneWithoutMembersInput
  user: UserUpdateOneWithoutTeamsInput
  accounts: TeamMemberAccountUpdateManyWithoutTeamMemberInput
}

input TeamMemberUpdateManyWithoutTeamInput {
  create: [TeamMemberCreateWithoutTeamInput!]
  connect: [TeamMemberWhereUniqueInput!]
  disconnect: [TeamMemberWhereUniqueInput!]
  delete: [TeamMemberWhereUniqueInput!]
  update: [TeamMemberUpdateWithWhereUniqueWithoutTeamInput!]
  upsert: [TeamMemberUpsertWithWhereUniqueWithoutTeamInput!]
}

input TeamMemberUpdateManyWithoutUserInput {
  create: [TeamMemberCreateWithoutUserInput!]
  connect: [TeamMemberWhereUniqueInput!]
  disconnect: [TeamMemberWhereUniqueInput!]
  delete: [TeamMemberWhereUniqueInput!]
  update: [TeamMemberUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [TeamMemberUpsertWithWhereUniqueWithoutUserInput!]
}

input TeamMemberUpdateOneWithoutAccountsInput {
  create: TeamMemberCreateWithoutAccountsInput
  connect: TeamMemberWhereUniqueInput
  delete: Boolean
  update: TeamMemberUpdateWithoutAccountsDataInput
  upsert: TeamMemberUpsertWithoutAccountsInput
}

input TeamMemberUpdateWithoutAccountsDataInput {
  role: TeamMemberRole
  canInvite: Boolean
  team: TeamUpdateOneWithoutMembersInput
  user: UserUpdateOneWithoutTeamsInput
}

input TeamMemberUpdateWithoutTeamDataInput {
  role: TeamMemberRole
  canInvite: Boolean
  user: UserUpdateOneWithoutTeamsInput
  accounts: TeamMemberAccountUpdateManyWithoutTeamMemberInput
}

input TeamMemberUpdateWithoutUserDataInput {
  role: TeamMemberRole
  canInvite: Boolean
  team: TeamUpdateOneWithoutMembersInput
  accounts: TeamMemberAccountUpdateManyWithoutTeamMemberInput
}

input TeamMemberUpdateWithWhereUniqueWithoutTeamInput {
  where: TeamMemberWhereUniqueInput!
  data: TeamMemberUpdateWithoutTeamDataInput!
}

input TeamMemberUpdateWithWhereUniqueWithoutUserInput {
  where: TeamMemberWhereUniqueInput!
  data: TeamMemberUpdateWithoutUserDataInput!
}

input TeamMemberUpsertWithoutAccountsInput {
  update: TeamMemberUpdateWithoutAccountsDataInput!
  create: TeamMemberCreateWithoutAccountsInput!
}

input TeamMemberUpsertWithWhereUniqueWithoutTeamInput {
  where: TeamMemberWhereUniqueInput!
  update: TeamMemberUpdateWithoutTeamDataInput!
  create: TeamMemberCreateWithoutTeamInput!
}

input TeamMemberUpsertWithWhereUniqueWithoutUserInput {
  where: TeamMemberWhereUniqueInput!
  update: TeamMemberUpdateWithoutUserDataInput!
  create: TeamMemberCreateWithoutUserInput!
}

input TeamMemberWhereInput {
  """Logical AND on all given filters."""
  AND: [TeamMemberWhereInput!]

  """Logical OR on all given filters."""
  OR: [TeamMemberWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [TeamMemberWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  role: TeamMemberRole

  """All values that are not equal to given value."""
  role_not: TeamMemberRole

  """All values that are contained in given list."""
  role_in: [TeamMemberRole!]

  """All values that are not contained in given list."""
  role_not_in: [TeamMemberRole!]
  canInvite: Boolean

  """All values that are not equal to given value."""
  canInvite_not: Boolean
  team: TeamWhereInput
  user: UserWhereInput
  accounts_every: TeamMemberAccountWhereInput
  accounts_some: TeamMemberAccountWhereInput
  accounts_none: TeamMemberAccountWhereInput
}

input TeamMemberWhereUniqueInput {
  id: ID
}

enum TeamOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  nameNormalized_ASC
  nameNormalized_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type TeamPreviousValues {
  id: ID!
  name: String!
  nameNormalized: String
}

type TeamSubscriptionPayload {
  mutation: MutationType!
  node: Team
  updatedFields: [String!]
  previousValues: TeamPreviousValues
}

input TeamSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [TeamSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [TeamSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [TeamSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: TeamWhereInput
}

input TeamUpdateInput {
  name: String
  nameNormalized: String
  accounts: AccountUpdateManyWithoutTeamInput
  members: TeamMemberUpdateManyWithoutTeamInput
}

input TeamUpdateOneWithoutAccountsInput {
  create: TeamCreateWithoutAccountsInput
  connect: TeamWhereUniqueInput
  delete: Boolean
  update: TeamUpdateWithoutAccountsDataInput
  upsert: TeamUpsertWithoutAccountsInput
}

input TeamUpdateOneWithoutMembersInput {
  create: TeamCreateWithoutMembersInput
  connect: TeamWhereUniqueInput
  delete: Boolean
  update: TeamUpdateWithoutMembersDataInput
  upsert: TeamUpsertWithoutMembersInput
}

input TeamUpdateWithoutAccountsDataInput {
  name: String
  nameNormalized: String
  members: TeamMemberUpdateManyWithoutTeamInput
}

input TeamUpdateWithoutMembersDataInput {
  name: String
  nameNormalized: String
  accounts: AccountUpdateManyWithoutTeamInput
}

input TeamUpsertWithoutAccountsInput {
  update: TeamUpdateWithoutAccountsDataInput!
  create: TeamCreateWithoutAccountsInput!
}

input TeamUpsertWithoutMembersInput {
  update: TeamUpdateWithoutMembersDataInput!
  create: TeamCreateWithoutMembersInput!
}

input TeamWhereInput {
  """Logical AND on all given filters."""
  AND: [TeamWhereInput!]

  """Logical OR on all given filters."""
  OR: [TeamWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [TeamWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  nameNormalized: String

  """All values that are not equal to given value."""
  nameNormalized_not: String

  """All values that are contained in given list."""
  nameNormalized_in: [String!]

  """All values that are not contained in given list."""
  nameNormalized_not_in: [String!]

  """All values less than the given value."""
  nameNormalized_lt: String

  """All values less than or equal the given value."""
  nameNormalized_lte: String

  """All values greater than the given value."""
  nameNormalized_gt: String

  """All values greater than or equal the given value."""
  nameNormalized_gte: String

  """All values containing the given string."""
  nameNormalized_contains: String

  """All values not containing the given string."""
  nameNormalized_not_contains: String

  """All values starting with the given string."""
  nameNormalized_starts_with: String

  """All values not starting with the given string."""
  nameNormalized_not_starts_with: String

  """All values ending with the given string."""
  nameNormalized_ends_with: String

  """All values not ending with the given string."""
  nameNormalized_not_ends_with: String
  accounts_every: AccountWhereInput
  accounts_some: AccountWhereInput
  accounts_none: AccountWhereInput
  members_every: TeamMemberWhereInput
  members_some: TeamMemberWhereInput
  members_none: TeamMemberWhereInput
}

input TeamWhereUniqueInput {
  id: ID
}

type User implements Node {
  id: ID!
  email: String!
  emailNormalized: String
  firstName: String!
  lastName: String
  passwordHash: String!
  teams(where: TeamMemberWhereInput, orderBy: TeamMemberOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TeamMember!]
}

"""A connection to a list of items."""
type UserConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  email: String!
  emailNormalized: String
  firstName: String!
  lastName: String
  passwordHash: String!
  teams: TeamMemberCreateManyWithoutUserInput
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutTeamsInput {
  create: UserCreateWithoutTeamsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutTeamsInput {
  email: String!
  emailNormalized: String
  firstName: String!
  lastName: String
  passwordHash: String!
}

"""An edge in a connection."""
type UserEdge {
  """The item at the end of the edge."""
  node: User!

  """A cursor for use in pagination."""
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  emailNormalized_ASC
  emailNormalized_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  passwordHash_ASC
  passwordHash_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type UserPreviousValues {
  id: ID!
  email: String!
  emailNormalized: String
  firstName: String!
  lastName: String
  passwordHash: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [UserSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [UserSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [UserSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: UserWhereInput
}

input UserUpdateDataInput {
  email: String
  emailNormalized: String
  firstName: String
  lastName: String
  passwordHash: String
  teams: TeamMemberUpdateManyWithoutUserInput
}

input UserUpdateInput {
  email: String
  emailNormalized: String
  firstName: String
  lastName: String
  passwordHash: String
  teams: TeamMemberUpdateManyWithoutUserInput
}

input UserUpdateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
}

input UserUpdateOneWithoutTeamsInput {
  create: UserCreateWithoutTeamsInput
  connect: UserWhereUniqueInput
  delete: Boolean
  update: UserUpdateWithoutTeamsDataInput
  upsert: UserUpsertWithoutTeamsInput
}

input UserUpdateWithoutTeamsDataInput {
  email: String
  emailNormalized: String
  firstName: String
  lastName: String
  passwordHash: String
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutTeamsInput {
  update: UserUpdateWithoutTeamsDataInput!
  create: UserCreateWithoutTeamsInput!
}

input UserWhereInput {
  """Logical AND on all given filters."""
  AND: [UserWhereInput!]

  """Logical OR on all given filters."""
  OR: [UserWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [UserWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  email: String

  """All values that are not equal to given value."""
  email_not: String

  """All values that are contained in given list."""
  email_in: [String!]

  """All values that are not contained in given list."""
  email_not_in: [String!]

  """All values less than the given value."""
  email_lt: String

  """All values less than or equal the given value."""
  email_lte: String

  """All values greater than the given value."""
  email_gt: String

  """All values greater than or equal the given value."""
  email_gte: String

  """All values containing the given string."""
  email_contains: String

  """All values not containing the given string."""
  email_not_contains: String

  """All values starting with the given string."""
  email_starts_with: String

  """All values not starting with the given string."""
  email_not_starts_with: String

  """All values ending with the given string."""
  email_ends_with: String

  """All values not ending with the given string."""
  email_not_ends_with: String
  emailNormalized: String

  """All values that are not equal to given value."""
  emailNormalized_not: String

  """All values that are contained in given list."""
  emailNormalized_in: [String!]

  """All values that are not contained in given list."""
  emailNormalized_not_in: [String!]

  """All values less than the given value."""
  emailNormalized_lt: String

  """All values less than or equal the given value."""
  emailNormalized_lte: String

  """All values greater than the given value."""
  emailNormalized_gt: String

  """All values greater than or equal the given value."""
  emailNormalized_gte: String

  """All values containing the given string."""
  emailNormalized_contains: String

  """All values not containing the given string."""
  emailNormalized_not_contains: String

  """All values starting with the given string."""
  emailNormalized_starts_with: String

  """All values not starting with the given string."""
  emailNormalized_not_starts_with: String

  """All values ending with the given string."""
  emailNormalized_ends_with: String

  """All values not ending with the given string."""
  emailNormalized_not_ends_with: String
  firstName: String

  """All values that are not equal to given value."""
  firstName_not: String

  """All values that are contained in given list."""
  firstName_in: [String!]

  """All values that are not contained in given list."""
  firstName_not_in: [String!]

  """All values less than the given value."""
  firstName_lt: String

  """All values less than or equal the given value."""
  firstName_lte: String

  """All values greater than the given value."""
  firstName_gt: String

  """All values greater than or equal the given value."""
  firstName_gte: String

  """All values containing the given string."""
  firstName_contains: String

  """All values not containing the given string."""
  firstName_not_contains: String

  """All values starting with the given string."""
  firstName_starts_with: String

  """All values not starting with the given string."""
  firstName_not_starts_with: String

  """All values ending with the given string."""
  firstName_ends_with: String

  """All values not ending with the given string."""
  firstName_not_ends_with: String
  lastName: String

  """All values that are not equal to given value."""
  lastName_not: String

  """All values that are contained in given list."""
  lastName_in: [String!]

  """All values that are not contained in given list."""
  lastName_not_in: [String!]

  """All values less than the given value."""
  lastName_lt: String

  """All values less than or equal the given value."""
  lastName_lte: String

  """All values greater than the given value."""
  lastName_gt: String

  """All values greater than or equal the given value."""
  lastName_gte: String

  """All values containing the given string."""
  lastName_contains: String

  """All values not containing the given string."""
  lastName_not_contains: String

  """All values starting with the given string."""
  lastName_starts_with: String

  """All values not starting with the given string."""
  lastName_not_starts_with: String

  """All values ending with the given string."""
  lastName_ends_with: String

  """All values not ending with the given string."""
  lastName_not_ends_with: String
  passwordHash: String

  """All values that are not equal to given value."""
  passwordHash_not: String

  """All values that are contained in given list."""
  passwordHash_in: [String!]

  """All values that are not contained in given list."""
  passwordHash_not_in: [String!]

  """All values less than the given value."""
  passwordHash_lt: String

  """All values less than or equal the given value."""
  passwordHash_lte: String

  """All values greater than the given value."""
  passwordHash_gt: String

  """All values greater than or equal the given value."""
  passwordHash_gte: String

  """All values containing the given string."""
  passwordHash_contains: String

  """All values not containing the given string."""
  passwordHash_not_contains: String

  """All values starting with the given string."""
  passwordHash_starts_with: String

  """All values not starting with the given string."""
  passwordHash_not_starts_with: String

  """All values ending with the given string."""
  passwordHash_ends_with: String

  """All values not ending with the given string."""
  passwordHash_not_ends_with: String
  teams_every: TeamMemberWhereInput
  teams_some: TeamMemberWhereInput
  teams_none: TeamMemberWhereInput
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
